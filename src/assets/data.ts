export const weaknesses = 
{'5': {'Shortname': 'J2EE: No Encrypted Transmission ', 'Name': 'J2EE Misconfiguration: Data Transmission Without Encryption', 'Comment': 'Category J2EE Environment Issues', 'Description': 'Information sent over a network can be compromised while in transit. An attacker may be able toread or modify the contents if the data are sent in plaintext or are weakly encrypted.', 'Source': 'CWE', '': '', 'ID': '5', 'OWASP': ['5'], 'Measures': ['1051'], 'Phases': ['Implementation', 'Operation']}, '6': {'Shortname': 'J2EE: Insufficient Session-ID Length', 'Name': 'J2EE Misconfiguration: Insufficient Session-ID Length', 'Comment': 'Category J2EE Environment Issues', 'Description': 'The J2EE application is configured to use an insufficient session ID length.', 'Source': 'CWE', '': '', 'ID': '6', 'OWASP': ['5'], 'Measures': ['1061', '1062'], 'Phases': ['Architecture and Design', 'Implementation']}, '7': {'Shortname': 'J2EE: Missing Custom Error Page', 'Name': 'J2EE Misconfiguration: Missing Custom Error Page', 'Comment': 'Category J2EE Environment Issues', 'Description': 'The default error page of a web application should not display sensitive information about thesoftware system.', 'Source': 'CWE', '': '', 'ID': '7', 'OWASP': ['5'], 'Measures': ['1071', '1072', '1073', '1074'], 'Phases': ['Architecture and Design', 'Implementation']}, '8': {'Shortname': 'J2EE: Entity Bean Declared Remote', 'Name': 'J2EE Misconfiguration: Entity Bean Declared Remote', 'Comment': 'Category J2EE Environment Issues', 'Description': "When an application exposes a remote interface for an entity bean, it might also expose methodsthat get or set the bean's data. These methods could be leveraged to read sensitive information,or to change data in ways that violate the application's expectations, potentially leading to othervulnerabilities.", 'Source': 'CWE', '': '', 'ID': '8', 'OWASP': ['5'], 'Measures': ['1081'], 'Phases': ['Architecture and Design', 'Implementation']}, '9': {'Shortname': 'J2EE: EJB Method Permissions', 'Name': 'J2EE Misconfiguration: Weak Access Permissions for EJB Methods', 'Comment': 'Category J2EE Environment Issues', 'Description': 'If elevated access rights are assigned to EJB methods, then an attacker can take advantage of thepermissions to exploit the software system.', 'Source': 'CWE', '': '', 'ID': '9', 'OWASP': ['5'], 'Measures': ['1091'], 'Phases': ['Architecture and Design', 'Implementation']}, '11': {'Shortname': 'ASP.NET: Debug Binary', 'Name': 'ASP.NET Misconfiguration: Creating Debug Binary', 'Comment': 'Category .NET Environment', 'Description': 'Debugging messages help attackers learn about the system and plan a form of attack.', 'Source': 'CWE', '': '', 'ID': '11', 'OWASP': ['5'], 'Measures': ['1111'], 'Phases': ['Implementation', 'Operation']}, '12': {'Shortname': 'ASP.NET: Missing Custom Error Page', 'Name': 'ASP.NET Misconfiguration: Missing Custom Error Page', 'Comment': 'Category .NET Environment', 'Description': "An ASP .NET application must enable custom error pages in order to prevent attackers from mininginformation from the framework's built-in responses.", 'Source': 'CWE', '': '', 'ID': '12', 'OWASP': ['5'], 'Measures': ['1074', '1121', '1122'], 'Phases': ['Implementation', 'Operation']}, '13': {'Shortname': 'ASP.NET: Password in Config', 'Name': 'ASP.NET Misconfiguration: Password in Configuration File', 'Comment': 'Category .NET Environment', 'Description': 'Storing a plaintext password in a configuration file allows anyone who can read the file access tothe password-protected resource making them an easy target for attackers.', 'Source': 'CWE', '': '', 'ID': '13', 'OWASP': ['5'], 'Measures': ['1131'], 'Phases': ['Architecture and Design', 'Implementation']}, '14': {'Shortname': 'Buffer Clear Code', 'Name': 'Compiler Removal of Code to Clear Buffers', 'Comment': '', 'Description': 'Sensitive memory is cleared according to the source code, but compiler optimizations leave the memory untouched when it is not read from again, aka "dead store removal."', 'Source': 'CWE', '': '', 'ID': '14', 'OWASP': ['5'], 'Measures': ['22', '68', '114'], 'Phases': ['Implementation', 'Build and Compilation']}, '22': {'Shortname': 'Path Traversal', 'Name': "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", 'Comment': '', 'Description': 'The software uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the software does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.', 'Source': 'CWE', '': '', 'ID': '22', 'OWASP': ['4'], 'Measures': ['18', '48', '64', '110', '156', '202', '248', '294', '386', '418', '432'], 'Phases': ['Architecture and Design', 'Implementation']}, '77': {'Shortname': 'Command Injection', 'Name': "Improper Neutralization of Special Elements used in a Command ('Command Injection')", 'Comment': '', 'Description': 'The software constructs all or part of a command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended command when it is sent to a downstream component.', 'Source': 'CWE', '': '', 'ID': '77', 'OWASP': ['1'], 'Measures': ['1', '5', '47', '139', '185'], 'Phases': ['Architecture and Design', 'Implementation']}, '78': {'Shortname': 'OS Command Injection', 'Name': "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", 'Comment': '', 'Description': 'The software constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.', 'Source': 'CWE', '': '', 'ID': '78', 'OWASP': ['1'], 'Measures': ['1', '48', '64', '94', '186', '202', '232', '248', '278', '280', '324', '370', '418', '462', '554', '600'], 'Phases': ['Architecture and Design', 'Implementation']}, '79': {'Shortname': 'Cross-site Scripting', 'Name': "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", 'Comment': '', 'Description': 'The software does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.', 'Source': 'CWE', '': '', 'ID': '79', 'OWASP': ['3'], 'Measures': ['17', '63', '64', '109', '201', '202', '247', '280', '293', '339', '385', '418'], 'Phases': ['Architecture and Design', 'Implementation']}, '88': {'Shortname': 'Argument Injection', 'Name': 'Argument Injection or Modification', 'Comment': '', 'Description': 'The software does not sufficiently delimit the arguments being passed to a component in another control sphere, allowing alternate arguments to be provided, leading to potentially security-relevant changes.', 'Source': 'CWE', '': '', 'ID': '88', 'OWASP': ['1'], 'Measures': ['3', '5', '95', '141', '187', '233', '279', '325'], 'Phases': ['Architecture and Design', 'Implementation']}, '89': {'Shortname': 'SQL Injection', 'Name': "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')", 'Comment': '', 'Description': 'The software constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.', 'Source': 'CWE', '': '', 'ID': '89', 'OWASP': ['1'], 'Measures': ['4', '50', '64', '96', '188', '202', '234', '280', '326', '418'], 'Phases': ['Architecture and Design', 'Implementation', 'Deployment']}, '90': {'Shortname': 'LDAP Injection', 'Name': "Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", 'Comment': '', 'Description': 'The software constructs all or part of an LDAP query using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended LDAP query when it is sent to a downstream component.', 'Source': 'CWE', '': '', 'ID': '90', 'OWASP': ['1'], 'Measures': ['5'], 'Phases': ['Architecture and Design', 'Implementation']}, '91': {'Shortname': 'XPath Injection', 'Name': 'XML Injection (aka Blind XPath Injection)', 'Comment': '', 'Description': 'The software does not properly neutralize special elements that are used in XML, allowing attackers to modify the syntax, content, or commands of the XML before it is processed by an end system.', 'Source': 'CWE', '': '', 'ID': '91', 'OWASP': ['1'], 'Measures': ['5'], 'Phases': ['Architecture and Design', 'Implementation']}, '99': {'Shortname': 'Resource Injection', 'Name': "Improper Control of Resource Identifiers ('Resource Injection')", 'Comment': '', 'Description': 'The software receives input from an upstream component, but it does not restrict or incorrectly restricts the input before it is used as an identifier for a resource that may be outside the intended sphere of control.', 'Source': 'CWE', '': '', 'ID': '99', 'OWASP': ['4'], 'Measures': ['5'], 'Phases': ['Architecture and Design', 'Implementation']}, '209': {'Shortname': 'Error Message Exposure', 'Name': 'Information Exposure Through an Error Message', 'Comment': '', 'Description': 'The software generates an error message that includes sensitive information about its environment, users, or associated data.', 'Source': 'CWE', '': '', 'ID': '209', 'OWASP': ['5'], 'Measures': ['23', '69', '115', '161', '253', '299'], 'Phases': ['Architecture and Design', 'Implementation', 'System Configuration', 'Deployment']}, '215': {'Shortname': 'Debug Info Exposure', 'Name': 'Information Exposure Through Debug Information', 'Comment': '', 'Description': 'The application contains debugging code that can expose sensitive information to untrusted parties.', 'Source': 'CWE', '': '', 'ID': '215', 'OWASP': ['5'], 'Measures': ['24', '70'], 'Phases': ['Architecture and Design', 'Implementation', 'Deployment']}, '256': {'Shortname': 'Plaintext Password', 'Name': 'Plaintext Storage of a Password', 'Comment': '', 'Description': 'Storing a password in plaintext may result in a system compromise.', 'Source': 'CWE', '': '', 'ID': '256', 'OWASP': ['2'], 'Measures': ['7', '53', '99'], 'Phases': ['Architecture and Design']}, '285': {'Shortname': 'Improper Authorization', 'Name': 'Improper Authorization', 'Comment': '', 'Description': 'The software does not perform or incorrectly performs an authorization check when an actor attempts to access a resource or perform an action.', 'Source': 'CWE', '': '', 'ID': '285', 'OWASP': ['7'], 'Measures': ['43', '89', '135', '181', '227'], 'Phases': ['Architecture and Design', 'Implementation', 'Deployment']}, '287': {'Shortname': 'Improper Authentication', 'Name': 'Improper Authentication', 'Comment': '', 'Description': 'When an actor claims to have a given identity, the software does not prove or insufficiently proves that the claim is correct.', 'Source': 'CWE', '': '', 'ID': '287', 'OWASP': ['2', '7'], 'Measures': ['8'], 'Phases': ['Architecture and Design', 'Implementation']}, '295': {'Shortname': 'Improper Certificate Validation', 'Name': 'Improper Certificate Validation', 'Comment': '', 'Description': 'The software does not validate, or incorrectly validates, a certificate.', 'Source': 'CWE', '': '', 'ID': '295', 'OWASP': ['6'], 'Measures': ['28'], 'Phases': ['Architecture and Design', 'Implementation']}, '311': {'Shortname': 'Missing Encryption', 'Name': 'Missing Encryption of Sensitive Data', 'Comment': '', 'Description': 'The software does not encrypt sensitive or critical information before storage or transmission.', 'Source': 'CWE', '': '', 'ID': '311', 'OWASP': ['2', '6'], 'Measures': ['9', '38', '55', '70', '115', '193'], 'Phases': ['Architecture and Design', 'Deployment']}, '312': {'Shortname': 'Cleartext Storage', 'Name': 'Cleartext Storage of Sensitive Information', 'Comment': '', 'Description': 'The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere.', 'Source': 'CWE', '': '', 'ID': '312', 'OWASP': ['6'], 'Measures': ['9', '38', '55', '70', '115', '193'], 'Phases': ['Architecture and Design']}, '319': {'Shortname': 'Cleartext Transmission', 'Name': 'Cleartext Transmission of Sensitive Information', 'Comment': '', 'Description': 'The software transmits sensitive or security-critical data in cleartext in a communication channel that can be sniffed by unauthorized actors.', 'Source': 'CWE', '': '', 'ID': '319', 'OWASP': ['2', '6'], 'Measures': ['10', '56', '102', '148'], 'Phases': ['Architecture and Design', 'System Configuration', 'Deployment']}, '321': {'Shortname': 'Hard-coded Keys', 'Name': 'Use of Hard-coded Cryptographic Key', 'Comment': '', 'Description': 'The use of a hard-coded cryptographic key significantly increases the possibility that encrypted data may be recovered.', 'Source': 'CWE', '': '', 'ID': '321', 'OWASP': ['6'], 'Measures': ['3201', '3202', '3203', '3204', '3205'], 'Phases': ['Architecture and Design']}, '322': {'Shortname': 'Unauthenticated Key Exchange', 'Name': 'Key Exchange without Entity Authentication', 'Comment': '', 'Description': 'The software performs a key exchange with an actor without verifying the identity of that actor.', 'Source': 'CWE', '': '', 'ID': '322', 'OWASP': ['6'], 'Measures': ['33', '79'], 'Phases': ['Architecture and Design']}, '323': {'Shortname': 'Reusing Nonce', 'Name': 'Reusing a Nonce, Key Pair in Encryption', 'Comment': '', 'Description': 'Nonces should be used for the present occasion and only once.', 'Source': 'CWE', '': '', 'ID': '323', 'OWASP': ['6'], 'Measures': ['34', '80'], 'Phases': ['Architecture and Design']}, '324': {'Shortname': 'Using Expired Key', 'Name': 'Use of a Key Past its Expiration Date', 'Comment': '', 'Description': 'The product uses a cryptographic key or password past its expiration date, which diminishes its safety significantly by increasing the timing window for cracking attacks against that key.', 'Source': 'CWE', '': '', 'ID': '324', 'OWASP': ['6'], 'Measures': ['35'], 'Phases': ['Architecture and Design']}, '325': {'Shortname': 'Missing Cryptographic Steps', 'Name': 'Missing Required Cryptographic Step', 'Comment': '', 'Description': 'The software does not implement a required step in a cryptographic algorithm, resulting in weaker encryption than advertised by that algorithm.', 'Source': 'CWE', '': '', 'ID': '325', 'OWASP': ['6'], 'Measures': ['176', '3251'], 'Phases': ['Requirements', 'Architecture and Design', 'Implementation']}, '326': {'Shortname': 'Weak Encryption', 'Name': 'Inadequate Encryption Strength', 'Comment': '', 'Description': 'The software stores or transmits sensitive data using an encryption scheme that is theoretically sound, but is not strong enough for the level of protection required.', 'Source': 'CWE', '': '', 'ID': '326', 'OWASP': ['6'], 'Measures': ['37'], 'Phases': ['Architecture and Design']}, '327': {'Shortname': 'Risky Cryptography', 'Name': 'Use of a Broken or Risky Cryptographic Algorithm', 'Comment': '', 'Description': 'The use of a broken or risky cryptographic algorithm is an unnecessary risk that may result in the exposure of sensitive information.', 'Source': 'CWE', '': '', 'ID': '327', 'OWASP': ['6'], 'Measures': ['38', '84', '130', '176', '193'], 'Phases': ['Architecture and Design']}, '328': {'Shortname': 'Reversible Hash', 'Name': 'Reversible One-Way Hash', 'Comment': '', 'Description': 'The product uses a hashing algorithm that produces a hash value that can be used to determine the original input, or to find an input that can produce the same hash, more efficiently than brute force techniques.', 'Source': 'CWE', '': '', 'ID': '328', 'OWASP': ['6'], 'Measures': ['39'], 'Phases': ['Architecture and Design']}, '329': {'Shortname': 'No Random IV', 'Name': 'Not Using a Random IV with CBC Mode', 'Comment': '', 'Description': 'Not using a random initialization Vector (IV) with Cipher Block Chaining (CBC) Mode causes algorithms to be susceptible to dictionary attacks.', 'Source': 'CWE', '': '', 'ID': '329', 'OWASP': ['6'], 'Measures': ['40'], 'Phases': ['Architecture and Design', 'Implementation']}, '347': {'Shortname': 'Improper Signature Verification', 'Name': 'Improper Verification of Cryptographic Signature', 'Comment': '', 'Description': 'The software does not verify, or incorrectly verifies, the cryptographic signature for data.', 'Source': 'CWE', '': '', 'ID': '347', 'OWASP': ['6'], 'Measures': ['3471', '3472'], 'Phases': ['Architecture and Design', 'Implementation']}, '352': {'Shortname': 'CSRF', 'Name': 'Cross-Site Request Forgery (CSRF)', 'Comment': '', 'Description': 'The web application does not, or can not, sufficiently verify whether a well-formed, valid, consistent request was intentionally provided by the user who submitted the request.', 'Source': 'CWE', '': '', 'ID': '352', 'OWASP': ['8'], 'Measures': ['45', '91', '137', '183', '229', '275', '321'], 'Phases': ['Architecture and Design']}, '384': {'Shortname': 'Session Fixation', 'Name': 'Session Fixation', 'Comment': '', 'Description': 'Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.', 'Source': 'CWE', '': '', 'ID': '384', 'OWASP': ['2'], 'Measures': ['11', '57'], 'Phases': ['Architecture and Design', 'Implementation']}, '435': {'Shortname': 'Improper Entity Interaction', 'Name': 'Improper Interaction Between Multiple Entities', 'Comment': '', 'Description': 'The software does not sufficiently verify the origin or authenticity of data, in a way that causes it to accept invalid data.', 'Source': 'CWE', '': '', 'ID': '435', 'OWASP': ['5'], 'Measures': ['4351'], 'Phases': ['Architecture and Design', 'Implementation', 'Deployment']}, '520': {'Shortname': '.NET: Impersonation', 'Name': '.NET Misconfiguration: Use of Impersonation', 'Comment': 'Category .NET Environment', 'Description': 'Allowing a .NET application to run at potentially escalated levels of access to the underlyingoperating and file systems can be dangerous and result in various forms of attacks.', 'Source': 'CWE', '': '', 'ID': '520', 'OWASP': ['5'], 'Measures': ['5201'], 'Phases': ['Architecture and Design', 'Implementation', 'Operation']}, '522': {'Shortname': 'Insufficiently Protected Credentials', 'Name': 'Insufficiently Protected Credentials', 'Comment': '', 'Description': 'This weakness occurs when the application transmits or stores authentication credentials and uses an insecure method that is susceptible to unauthorized interception and/or retrieval.', 'Source': 'CWE', '': '', 'ID': '522', 'OWASP': ['2'], 'Measures': ['12', '58', '104'], 'Phases': ['Architecture and Design', 'Implementation']}, '523': {'Shortname': 'Unprotected Transport of Credentials', 'Name': 'Unprotected Transport of Credentials', 'Comment': '', 'Description': 'Login pages not using adequate measures to protect the user name and password while they are in transit from the client to the server.', 'Source': 'CWE', '': '', 'ID': '523', 'OWASP': ['2'], 'Measures': ['13'], 'Phases': ['Architecture and Design']}, '548': {'Shortname': 'Directory Listing Exposure', 'Name': 'Information Exposure Through Directory Listing', 'Comment': '', 'Description': 'A directory listing is inappropriately exposed, yielding potentially sensitive information to attackers.', 'Source': 'CWE', '': '', 'ID': '548', 'OWASP': ['5'], 'Measures': ['27'], 'Phases': ['Implementation', 'Deployment']}, '554': {'Shortname': 'ASP.NET: No Input Validation', 'Name': 'ASP.NET Misconfiguration: Not Using Input Validation Framework', 'Comment': 'Category .NET Environment', 'Description': 'The ASP.NET application does not use an input validation framework.', 'Source': 'CWE', '': '', 'ID': '554', 'OWASP': ['5'], 'Measures': ['5541'], 'Phases': ['Architecture and Design', 'Implementation']}, '555': {'Shortname': 'J2EE: Plaintext Password', 'Name': 'J2EE Misconfiguration: Plaintext Password in Configuration File', 'Comment': 'Category J2EE Environment Issues', 'Description': 'The J2EE application stores a plaintext password in a configuration file.', 'Source': 'CWE', '': '', 'ID': '555', 'OWASP': ['5'], 'Measures': ['5551', '5552'], 'Phases': ['Architecture and Design', 'Implementation']}, '556': {'Shortname': 'ASP.NET: Identity Impersonation', 'Name': 'ASP.NET Misconfiguration: Use of Identity Impersonation', 'Comment': 'Category .NET Environment', 'Description': 'Configuring an ASP.NET application to run with impersonated credentials may give the applicationunnecessary privileges.', 'Source': 'CWE', '': '', 'ID': '556', 'OWASP': ['5'], 'Measures': ['5561'], 'Phases': ['Implementation', 'Operation']}, '601': {'Shortname': 'Open Redirect', 'Name': "URL Redirection to Untrusted Site ('Open Redirect')", 'Comment': '', 'Description': 'A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.', 'Source': 'CWE', '': '', 'ID': '601', 'OWASP': ['10'], 'Measures': ['46', '92', '138', '184', '202', '230'], 'Phases': ['Architecture and Design', 'Implementation']}, '613': {'Shortname': 'Insufficient Session Expiration', 'Name': 'Insufficient Session Expiration', 'Comment': '', 'Description': 'According to WASC, Insufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization.', 'Source': 'CWE', '': '', 'ID': '613', 'OWASP': ['2'], 'Measures': ['14'], 'Phases': ['Architecture and Design', 'Implementation']}, '620': {'Shortname': 'Unverified Password Change', 'Name': 'Unverified Password Change', 'Comment': '', 'Description': 'When setting a new password for a user, the product does not require knowledge of the original password, or using another form of authentication.', 'Source': 'CWE', '': '', 'ID': '620', 'OWASP': ['2'], 'Measures': ['15', '61'], 'Phases': ['Architecture and Design', 'Implementation']}, '639': {'Shortname': 'Authorization Bypass', 'Name': 'Authorization Bypass Through User-Controlled Key', 'Comment': '', 'Description': "The system's authorization functionality does not prevent one user from gaining access to another user's data or record by modifying the key value identifying the data.", 'Source': 'CWE', '': '', 'ID': '639', 'OWASP': ['4'], 'Measures': ['20', '66', '112'], 'Phases': ['Architecture and Design']}, '640': {'Shortname': 'Weak Password Recovery ', 'Name': 'Weak Password Recovery Mechanism for Forgotten Password', 'Comment': '', 'Description': 'The software contains a mechanism for users to recover or change their passwords without knowing the original password, but the mechanism is weak.', 'Source': 'CWE', '': '', 'ID': '640', 'OWASP': ['2'], 'Measures': ['16', '62', '108', '154', '200', '246'], 'Phases': ['Architecture and Design', 'Implementation']}, '780': {'Shortname': 'RSA without OAEP', 'Name': 'Use of RSA Algorithm without OAEP', 'Comment': '', 'Description': 'The software uses the RSA algorithm but does not incorporate Optimal Asymmetric Encryption Padding (OAEP), which might weaken the encryption.', 'Source': 'CWE', '': '', 'ID': '780', 'OWASP': ['6'], 'Measures': ['7801'], 'Phases': ['Architecture and Design', 'Implementation']}, '937': {'Shortname': 'Components with Known Vulnerabilities', 'Name': 'Using Components with Known Vulnerabilities', 'Comment': 'Mock CWE, as not suitable to CWE concept', 'Description': 'Mock CWE, as not suitable to CWE concept. It is numbered in compliance with the CWE for the category containing the weaknesses related to this OWASP risk.', 'Source': 'CWE', '': '', 'ID': '937', 'OWASP': ['9'], 'Measures': ['901', '902'], 'Phases': ['N/A']}}
export const measures = 
{'1': {'Name': 'Library Calls', 'Effectiveness': '', 'Description': 'If at all possible, use library calls rather than external processes to recreate the desired functionality.', 'Agility': 'The selection of the library encapsulating the calls has to be performed once according to the particular requirements. This library has to be used correctly in each increment involving command calls (and has to be used in the first place). As with all external dependencies, the library has to be kept up-to-date regarding updates and patches.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Selection of library', 'ActionPI': 'Correct use of library', 'ActionCo': 'Monitoring of library', 'Verification': 'The selection of an appropriate library can be verified in a MAR. \\\\The correct use of the selected solution can be tested in multiple ways. Using ACA, the library can be marked as sanitizing operation. Then, command calls bypassing the library can be detected as unsanitized taint flow. Also, the correct use can be reviewed targeted in a MCR. An AVS or a MPT are only able to detect the result of a missing or incorrect use of the library (the weakness itself).\\\\The library can be monitored using an ADC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '3', 'MOC_Co': '0', 'Weaknesses': ['77', '78'], 'Phases': ['Architecture and Design']}, '3': {'Name': 'Well-defined interfaces', 'Effectiveness': '', 'Description': 'Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, request headers as well as content, URL components, e-mail, files, databases, and any external systems that provide data to the application. Perform input validation at well-defined interfaces.', 'Agility': 'This measure has more the character of awareness/training than a preventing or mitigating measure. In the actual development process, it has to be involved in every single increment by taking into account the implications on the attack surface. While this can be quite clear in an increment adding a new API, a refactoring of the architecture can affect the attack surface in multiple ways.', 'Source': 'CWE', 'Comment': 'Awareness/training', 'ActionOT': '', 'ActionPI': 'Understanding changed attack surface', 'ActionCo': '', 'Verification': 'This measure is not explicitly verifiable.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['88'], 'Phases': ['Architecture and Design']}, '4': {'Name': 'Use of Library or Framework', 'Effectiveness': '', 'Description': 'Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.', 'Agility': 'The selection of the library or framework encapsulating the access to the database has to be carried out once when connecting the database to the system. In every increment involving the access to the database the library/framework has to be used in a correct way. As with all external dependencies, the library or framework has to be kept up-to-date regarding updates and patches.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Selection of library/framework', 'ActionPI': 'Correct use of library/framework', 'ActionCo': 'Monitoring of library/framework', 'Verification': 'The selection of an appropriate library or framework can be verified in a MAR. \\\\The correct use of the selected solution can be tested in multiple ways. Using ACA, the library/framework can be marked as sanitizing operation. Then, database operations not using the library/framework can be detected as unsanitized taint flow. Also, the correct use can be reviewed targeted in a MCR. An AVS or a MPT are only able to detect the result of a missing or incorrect use of the library/framework (the weakness itself).\\\\ The library or framework can be monitored using an ADC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '3', 'MOC_Co': '0', 'Weaknesses': ['89'], 'Phases': ['Architecture and Design']}, '5': {'Name': 'Use Input Validation', 'Effectiveness': '', 'Description': "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.", 'Agility': 'Input validation can be realized in different ways, using white- or blacklists. As described above, whitelisting is the recommended strategy. The exact strategy has to be defined for the respective system. To avoid inconsistencies, this should be done one-time for the developed system. In every affected increment, the strategy must not be bypassed but used in the correct way. Independent of that, the strategy has to be maintained continuously, including new appearing security threats.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Define input validation strategy', 'ActionPI': 'Correct use of strategy', 'ActionCo': 'Maintain strategy', 'Verification': 'Using a MAR, the definition of the input validation strategy can be verified.\\\\The correct implementation of the strategy can be tested in multiple ways. Using ACA, the input validation operation (e.g. matching a whitelist) can be marked as sanitizing operation. Then, operations not using the strategy can be detected as unsanitized taint flow. Also, the correct use can be reviewed targeted in a MCR. An AVS or a MPT are only able to detect the result of a missing or incorrect use of the strategy (the weakness itself).\\\\ The maintenance of the strategy cannot be verified directly. It is conceivable to create a recurring reminder task in the used project management tool as MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['77', '88', '90', '91', '99'], 'Phases': ['Implementation']}, '7': {'Name': 'Password Storage Location', 'Effectiveness': '', 'Description': 'Avoid storing passwords in easily accessible locations.', 'Agility': 'In the beginning of the project or in the first increment involving the storage of passwords, a secure storage location has to be defined. Thus, the use of multiple locations with different security levels for every increment can be avoided. When an increment contains the storage of a new password, the defined location has to be used.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining storage locations', 'ActionPI': 'Storage in correct locations', 'ActionCo': '', 'Verification': 'The definition of secure storage solutions can only be verified in a MAR.\\\\ACA can partly verify this measure as they are able to detect hardcoded passwords, but cannot assure whether the measure itself is used properly. A MCR, in contrast, can verify the correct usage. An AVS or a MPT can detect if the passwords are stored in accessible locations.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '3', 'AVS_PI': '1', 'MPT_PI': '1', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['256'], 'Phases': ['Architecture and Design']}, '8': {'Name': 'Authentication Framework', 'Effectiveness': '', 'Description': 'Use an authentication framework or library such as the OWASP ESAPI Authentication feature.', 'Agility': 'This high-level measure recommends the use of a specific authentication framework instead of developing an own solution from scratch. This is a classic design decision, which is (also in agile projects) located at an early phase of the project. At this point, a suitable framework should be selected.  In every increment handling authentication or involving the access to restricted areas, the framework has to be used correctly. As with all external dependencies, it has to be kept up-to-date regarding updates and patches.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Selection of library/framework', 'ActionPI': 'Correct use of library/framework', 'ActionCo': 'Monitoring of library/framework', 'Verification': 'The selection of an appropriate framework can only be verified in a MAR. \\\\A MCR can verify the correct use of the framework, while an ACA is not able to do so. An AVS or a MPT are only able to detect authentication flaws as result of a missing or incorrect use of the framework (the weakness itself) but cannot verify the measure.\\\\ The library or framework can be monitored using an ADC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '3', 'MOC_Co': '0', 'Weaknesses': ['287'], 'Phases': ['Architecture and Design']}, '9': {'Name': 'Encryption for Relevant Data', 'Effectiveness': '', 'Description': 'Clearly specify which data or resources are valuable enough that they should be protected by encryption. Require that any transmission or storage of this data/resource should use well-vetted encryption algorithms.', 'Agility': 'The specification of the specific protection needs for the data should be done once for the project to ensure consistency. At this point, the belonging encryption algorithms should be defined as well. In each increment, the processed data has to be classified according to the definition and the resulting protection measures have to be applied correctly. A constant check has to be kept on the used encryption algorithms and their parameters to ensure their appropriateness.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Definition of data security levels, selection of encryption algorithm', 'ActionPI': 'Correct classification and usage of encryption measures', 'ActionCo': 'Monitoring of encryption algorithm', 'Verification': 'In a MAR, the definition of security levels and the selection of the encryption algorithms used can be verified. \\\\Because of the generality of this measure, an accurate classification regarding the verification is difficult. The realization can surely be reviewed in a MCR, while an ACA will likely not be able to verify this measure. A MPT can possibly detect missing or insecure encryption, as well as a AVS, but then human analysis is needed to decide on whether the not-encrypted data is sensitive or not. \\\\The monitoring of the encryption algorithm is possible using ADC if it is integrated in form of an external library. Otherwise, a recurring reminder task in the used project management tool can be helpful as a MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '1', 'MOC_Co': '1', 'Weaknesses': ['311', '312'], 'Phases': ['Requirements']}, '10': {'Name': 'Encrypted Transmission', 'Effectiveness': '', 'Description': 'Encrypt the data with a reliable encryption scheme before transmitting.', 'Agility': 'The selection of the encryption scheme should be performed once for a consistent use in the development project. In every increment, it has to be used correctly. The encryption scheme has to be monitored continuously regarding its security and appropriateness.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Selection of encryption scheme', 'ActionPI': 'Correct usage of encryption scheme', 'ActionCo': 'Monitoring of encryption scheme', 'Verification': 'In a MAR, the selection of the encryption scheme can be verified. \\\\The correct usage cannot be verified using ACA, but in a MCR. An AVS can detect the unencrypted transmission as well as a MPT. \\\\The monitoring of the encryption scheme is possible using ADC if it is integrated in form of an external library. Otherwise, a recurring reminder task in the used project management tool can be helpful as a MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '3', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '1', 'MOC_Co': '1', 'Weaknesses': ['319'], 'Phases': ['Architecture and Design']}, '11': {'Name': 'Invalidate Old Sessions', 'Effectiveness': '', 'Description': 'Invalidate any existing session identifiers prior to authorizing a new user session.', 'Agility': 'This measure neither requires preliminary actions nor continuous monitoring. When implementing the issuing of a new session in an increment, the invalidating of existing sessions has to be remembered.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Correct session management', 'ActionCo': '', 'Verification': 'The correct implementation of this measure can be verified using a MCR or in a MPT. Automated verification is more difficult: A ACA will not be able to detect the missing invalidation, and using an AVS is also not very promising either. A possible alternative is the creation of custom end-to-end tests as CAT which perform operations which issue a new user session (e.g. a login) and verify the invalidation of the previous session.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '3', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['384'], 'Phases': ['Architecture and Design']}, '12': {'Name': 'Protect Credentials', 'Effectiveness': '', 'Description': 'Use an appropriate security mechanism to protect the credentials.', 'Agility': 'The selection of the security mechanisms should be done consistently once for the development project. In every increment handling credentials, it has to be used correctly to encrypt those. The mechanisms has to be monitored continuously regarding its security and appropriateness.', 'Source': 'CWE', 'Comment': 'Very unspecific', 'ActionOT': 'Selection of security mechanism', 'ActionPI': 'Correct usage of security mechanism', 'ActionCo': 'Monitoring of security mechanism', 'Verification': 'The choice of security mechanisms used has to be verified in a MAR.\\\\ The correct use of the selected mechanisms depend on their character. ACA can partly verify this measure as they are able to detect hardcoded passwords, which may be helpful when verifying this measure. A MCR is certainly suitable to verify the correct usage. An AVS or a MPT can only the impacts of wrongly used or missing security mechanisms.\\\\The monitoring of the encryption scheme is possible using ADC if it is integrated in form of an external dependency. Otherwise, a recurring reminder task in the used project management tool can be helpful as a MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '1', 'MOC_Co': '1', 'Weaknesses': ['522'], 'Phases': ['Architecture and Design']}, '13': {'Name': 'Enforce SSL for Login', 'Effectiveness': '', 'Description': 'Enforce SSL use for the login page or any page used to transmit user credentials or other sensitive information. Even if the entire site does not use SSL, it MUST use SSL for login. Additionally, to help prevent phishing attacks, make sure that SSL serves the login page. SSL allows the user to verify the identity of the server to which they are connecting. If the SSL serves login page, the user can be certain they are talking to the proper end system. A phishing attack would typically redirect a user to a site that does not have a valid trusted server certificate issued from an authorized supplier.', 'Agility': 'As this measure requires the use of SSL just for the Login page, it is sufficient to consider it in the increment establishing the Login page. Note that this measure is partly in conflict with \\ownref{M-56}.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Enabling SSL for Login page', 'ActionCo': '', 'Verification': 'This measure cannot be verified by a MAR, an ACA or a MCR as it is located in a later phase. Both AVS and MPT are able to detect the absence of SSL.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '3', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['523'], 'Phases': ['System Configuration', 'Operation']}, '14': {'Name': 'Set Expiration Dates', 'Effectiveness': '', 'Description': 'Set sessions/credentials expiration date.', 'Agility': 'This measure does not require preliminary actions nor continuous monitoring. When implementing the issuing of a new session in an increment, an expiration date has to be set.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Set expiration date', 'ActionCo': '', 'Verification': 'As this measure is located in implementation, it can not be tested using a MAR. A SCA cannot verify this measure, while a MCR can. In a MPT, the expiration of sessions or credentials can be tested. This is also possible using an AVS, but may take some time, depending on the chosen expiration dates. If this takes too long, another possibility for automation is to create a custom testcase with a deliberately low period of validity to check the expiration mechanism itself.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '1', 'MPT_PI': '3', 'CAT_PI': '1', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['613'], 'Phases': ['Implementation']}, '15': {'Name': 'Checked Password Change', 'Effectiveness': '', 'Description': 'When prompting for a password change, force the user to provide the original password in addition to the new password.', 'Agility': 'This detailed measure only affects the increments handling a password change. As described above, a password change has to be legitimated with the old password.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Requiring old password', 'ActionCo': '', 'Verification': 'This measure cannot be verified by a MAR as it is an implementation task. Requiring the old password is kind of a logical measure. Thatâ€™s why both ACA and AVS fail to verify it, but performing a MCR or a MPT is possible. ', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['620'], 'Phases': ['Architecture and Design']}, '16': {'Name': 'Input Validation for Password Recovery', 'Effectiveness': '', 'Description': 'Make sure that all input supplied by the user to the password recovery mechanism is thoroughly filtered and validated.', 'Agility': 'This measure should be dealt with using the existing measures for input validation. Anyway, it only affects increments handling password change, and can be placed there.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Applying input validation for recovery mechanism', 'ActionCo': '', 'Verification': 'As this measure refers to input validation, the verification methods usable are based on those for input validation measures. Therefore, SCA and MCR can verify the use of input validation measures, while AVS and MPT can just detect the absence or misuse of them.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['640'], 'Phases': ['Architecture and Design']}, '17': {'Name': 'Use of Library or Framework', 'Effectiveness': '', 'Description': "Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.", 'Agility': 'The selection of the library or framework for encoding the output properly should be done at an early stage of the (front-end) development. In every increment involving the access to the database the library/framework has to be used in a correct way. As with all external dependencies, the library or framework has to be kept up-to-date regarding updates and patches.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Selection of library/framework', 'ActionPI': 'Correct use of library/framework', 'ActionCo': 'Monitoring of library/framework', 'Verification': 'The selection of an appropriate library or framework can be verified in a MAR. \\\\The correct use of the selected solution can be tested in multiple ways. Using ACA, the library/framework can be marked as sanitizing operation. Then, all usage of user-controlled input not using the library/framework can be detected as unsanitized taint flow. Also, the correct use can be reviewed targeted in a MCR. An AVS or a MPT are only able to detect the result of a missing or incorrect use of the library/framework (the XSS weakness itself).\\\\ The library or framework can be monitored using an ADC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '3', 'MOC_Co': '0', 'Weaknesses': ['79'], 'Phases': ['Architecture and Design']}, '18': {'Name': 'Use Input Validation', 'Effectiveness': '', 'Description': "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as / to avoid CWE-36. Use a whitelist of allowable file extensions, which will help to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE-184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.", 'Agility': 'Input validation can be done in different ways, using white- or blacklists. As described above, whitelisting is the recommended strategy. The exact strategy has to be defined for the respective system. In order to avoid inconsistencies, this should be done one-time for the developed system. In every affected increment, the strategy must not be bypassed but used in the correct way. Independently of that, the strategy has to be maintained continuously, including new appearing security threats.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining input validation strategy', 'ActionPI': 'Correct use of strategy', 'ActionCo': 'Maintaining strategy', 'Verification': 'Using a MAR, the definition of the input validation strategy can be verified.\\\\The correct implementation of the strategy can be tested in multiple ways. Using ACA, the input validation operation (e.g. matching a whitelist) can be marked as sanitizing operation. Then, operations not using the strategy can be detected as unsanitized taint flow. Also, the correct use can be reviewed targeted in a MCR. An AVS or a MPT are only able to detect the result of a missing or incorrect use of the strategy (the weakness itself).\\\\ The maintenance of the strategy cannot be verified directly. It is conceivable to create a recurring reminder task in the used project management tool as MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['22'], 'Phases': ['Implementation']}, '20': {'Name': 'Authorized Data Access', 'Effectiveness': '', 'Description': 'For each and every data access, ensure that the user has sufficient privilege to access the record that is being requested.', 'Agility': 'An initial data access control scheme should be established once in the early stage of the development. As typical for agile development projects, it does not have to contain all rules for all data and user roles. Instead, with ongoing development, new rules are added or existing rules readjusted. This has to be considered in every increment handling data accesses.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining access control', 'ActionPI': 'Applying correct access rules or add new', 'ActionCo': '', 'Verification': 'The definition and adjustments of the access control model can only be verified using a MAR. \\\\The correct realization of the ruleset is not possible using automated techniques like SCA or AVS, but using MCR or MPT. For automation purposes, custom testcases checking the access rights for certain areas can be created as CAT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '1', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['639'], 'Phases': ['Architecture and Design']}, '22': {'Name': 'Volatile Data Storage', 'Effectiveness': '', 'Description': 'Store the sensitive data in a volatile memory location if available.', 'Agility': 'In order to avoid the remaining of memory with sensitive data, an increment handling those data has to consider using a volatile memory location. This measure does not require special one-time or continuous actions. ', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Storing sensitive data in volatile memory location', 'ActionCo': '', 'Verification': 'This measure is only verifiable using a white-box approach as the code has to be analyzed. Because of the distinction between sensitive or not-sensitive data, a MCR is necessary.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['14'], 'Phases': ['Implementation']}, '23': {'Name': 'Minimal Error Messages', 'Effectiveness': '', 'Description': 'Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages - but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not.', 'Agility': 'At an early stage of development, an error handling policy should be established. Every increment has to follow this policy.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining error handling policy', 'ActionPI': 'Following policy', 'ActionCo': '', 'Verification': 'To review the error handling policy, a MAR is a possible verification method. \\\\The correct realization of the policy can be checked using a MCR. Only limited verification is achieved using ACA, AVS and MPT as they can only detect the weakness itself (the exposure of information).', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '2', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['209'], 'Phases': ['Implementation']}, '24': {'Name': 'Remove Debug Statements', 'Effectiveness': '', 'Description': 'Do not leave debug statements that could be executed in the source code. Assure that all debug information is eradicated before releasing the software.', 'Agility': 'When setting up the release strategy, i.e. establishing a continuous deployment pipeline, a step for the removal of debug statements has to be integrated. Such removal can be automatic in common CD tools.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Ensure automatic removal', 'ActionPI': '', 'ActionCo': '', 'Verification': 'The automatic removal of debug information during the build process has to be checked manually examining the CD-pipeline as a MOC. Beside that, the effect of not removing such information may be detected by AVS or MPT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '2', 'MPT_OT': '2', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['215'], 'Phases': ['Implementation']}, '27': {'Name': 'Avoid Directory Listings', 'Effectiveness': '', 'Description': 'Recommendations include restricting access to important directories or files by adopting a need to know requirement for both the document and server root, and turning off features such as Automatic Directory Listings that could expose private files and provide information that could be utilized by an attacker when formulating or conducting an attack.', 'Agility': 'The listing of directories can be avoided by a correct configuration of the server. This is a one-time action (for each server) that does not require additional action per increment.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Configuring server correctly', 'ActionPI': '', 'ActionCo': '', 'Verification': 'This measure can be verified by manually checking the server configuration once as MOC. Beside that, listed directories may be detected by AVS or MPT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '2', 'MPT_OT': '2', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['548'], 'Phases': ['Architecture and Design', 'System Configuration']}, '28': {'Name': 'Certificate Management', 'Effectiveness': '', 'Description': "Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.", 'Agility': 'This high-level measure demands a careful certificate management, which should be established once for the development project. The maintenance of the certificates is a continuous process during the project, not bound to single increments.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining certificate management', 'ActionPI': '', 'ActionCo': 'Maintaining certificates', 'Verification': 'The design of the certificate management has to be verified in a MAR.\\\\Controlling the maintenance of the certificates cannot be carried out automatically. It is conceivable to create a recurring reminder task in the used project management tool as MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['295'], 'Phases': ['Architecture and Design', 'Implementation']}, '33': {'Name': 'Proper Authentication', 'Effectiveness': '', 'Description': 'Ensure that proper authentication is included in the system design.', 'Agility': 'This high-level measure regarding "proper authentication" is located in the system design. In an agile development process, authentication typically is a key feature placed at an early increment, but is affecting multiple increments.', 'Source': 'CWE', 'Comment': 'Very unspecific', 'ActionOT': 'Defining proper authentication', 'ActionPI': 'Implementing proper authentication', 'ActionCo': '', 'Verification': 'The verification of this high-level measure is possible by a MAR for checking the authentication design. \\\\The realization if the design can be verified using a MCR. Additionally, the specific implications of the implementation can be checked using a MPT. Automated verification methods are hard to apply as authentication usually requires human intelligence for testing. ', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['322'], 'Phases': ['Architecture and Design']}, '34': {'Name': 'Unique Nonces', 'Effectiveness': '', 'Description': 'Refuse to reuse nonce values.', 'Agility': 'This practical measure only affects the implementation of encryption with nonces. In increments handling nonces, the developer has to pay attention to this measure. A one-time action or continuous monitoring is not necessary here.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Do not reuse nonce', 'ActionCo': '', 'Verification': 'To verify this implementation measure, a MCR can be performed. Using black-box tests, it is more difficult to detect the reuse of a nonce, but possible in a MPT. An automation of the verification is complicated.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '1', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['323'], 'Phases': ['Implementation']}, '35': {'Name': 'User Guidance in Key Management', 'Effectiveness': '', 'Description': "Adequate consideration should be put in to the user interface in order to notify users previous to the key's expiration, to explain the importance of new key generation and to walk users through the process as painlessly as possible.", 'Agility': 'This measure helps creating a more usable user interface, leading to an easier key management. It nearly defines a single separate feature that can be implemented in an increment.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing user guidance', 'ActionCo': '', 'Verification': 'The implementation of the user guidance can only be verified using manual methods as automated tools can not assess the usability. MCR is possible, but to check the user guidance from a dynamic point of view, a MPT is recommended.', 'VerificationSource': '', 'Type': ' Other ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '1', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['324'], 'Phases': ['Architecture and Design']}, '37': {'Name': 'Chose Strong Encryption', 'Effectiveness': '', 'Description': 'Use a cryptographic algorithm that is currently considered to be strong by experts in the field.', 'Agility': 'The selection of suitable cryptographic algorithms is a one-time action in a development project. A constant check has to be kept on the selected algorithms to ensure their up-to-date security.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Selection of cryptographic algorithm', 'ActionPI': '', 'ActionCo': 'Monitoring of cryptographic algorithm', 'Verification': 'The choice of cryptographic algorithms use has to be evaluated in a MAR.\\\\ The continuous monitoring of the algorithms cannot be verified directly. It is conceivable to create a recurring reminder task in the used project management tool as MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['326'], 'Phases': ['Architecture and Design']}, '38': {'Name': 'Adequate Data Encryption ', 'Effectiveness': '', 'Description': 'When there is a need to store or transmit sensitive data, use strong, up-to-date cryptographic algorithms to encrypt that data. Select a well-vetted algorithm that is currently considered to be strong by experts in the field, and use well-tested implementations. As with all cryptographic mechanisms, the source code should be available for analysis. For example, US government systems require FIPS 140-2 certification. Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak. Periodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF-267]', 'Agility': 'The selection of suitable cryptographic algorithms is a one-time action in a development project. A constant check has to be kept on the selected algorithms to ensure their up-to-date security.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Selection of cryptographic algorithm', 'ActionPI': '', 'ActionCo': 'Monitoring of cryptographic algorithm', 'Verification': 'The selection of an appropriate algorithm can be verified in a MAR. \\\\ The continuous monitoring of the algorithms cannot be verified directly. It is conceivable to create a recurring reminder task in the used project management tool as MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '3', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['311', '312', '327'], 'Phases': ['Architecture and Design']}, '39': {'Name': 'Chose Strong Hash Function', 'Effectiveness': 'High', 'Description': "Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (stretching) or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use. Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead. Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.", 'Agility': 'The selection of the hash algorithms used by the software should be done once according to the specific requirements in order to ensure consistency. As with all cryptographic functions, their up-to-dateness has to be checked continuously.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Selection of hash function', 'ActionPI': '', 'ActionCo': 'Monitoring of hash function', 'Verification': 'The selection of an appropriate hash function can be verified in a MAR. \\\\ The continuous monitoring of the function cannot be verified directly. It is conceivable to create a recurring reminder task in the used project management tool as MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '3', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['328'], 'Phases': ['Architecture and Design']}, '40': {'Name': 'Proper Initialization of CBC', 'Effectiveness': '', 'Description': 'It is important to properly initialize CBC operating block ciphers or their utility is lost.', 'Agility': 'This very specific measure affecting the implementation of cryptography with CBC mode has to be considered in increments involving those implementations.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Correct initialization', 'ActionCo': '', 'Verification': 'This specific measure has to be verified in a whitebox test. As ACA cannot cover this measure, a MCR is necessary.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['329'], 'Phases': ['Implementation']}, '43': {'Name': 'Role-Based Access Control', 'Effectiveness': '', 'Description': 'Divide the software into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) to enforce the roles at the appropriate boundaries. Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.', 'Agility': 'Dividing the software into different areas is difficult in agile development projects as the individual components emerge and  grow over time. Therefore, in agile projects, the initial measure is to define a framework of categories of areas and roles in the beginning. During each increment the concrete access control has to be defined and applied.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining access control', 'ActionPI': 'Applying correct access rules or adding new ones', 'ActionCo': '', 'Verification': 'The definition and adjustments of the access control model can only be verified using a MAR. \\\\ The correct realization of the ruleset is not possible using automated techniques like SCA or AVS, but using human guided methods like MCR or MPT. For automation purposes, custom testcases checking the access rights for certain areas can be created as CAT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '1', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['285'], 'Phases': ['Architecture and Design']}, '45': {'Name': 'Use of Library or Framework', 'Effectiveness': '', 'Description': 'Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330] Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]', 'Agility': 'Using a framework or library to avoid CSRF in an agile project means to select a suitable software solution beforehand. In each increment including request with the risk of CSRF, this framework has to be used in a correct way. As with all external dependencies, the library has to be kept up-to-date regarding updates and patches.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Selection of library/framework', 'ActionPI': 'Correct use of library/framework', 'ActionCo': 'Monitoring of library/framework', 'Verification': 'The selection of an appropriate library or framework can be verified in a MAR. \\\\ The correct use of the selected solution can be verified in a MCR. With dynamic methods, only the existence of the weakness (CSRF) is detectable. An AVS is hardly able to discover CSRF vulnerabilities, while a MPT is more promising.\\\\ The library or framework can be monitored using an ADC. ', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '3', 'MOC_Co': '0', 'Weaknesses': ['352'], 'Phases': ['Architecture and Design']}, '46': {'Name': 'Use Input Validation', 'Effectiveness': '', 'Description': "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. Use a whitelist of approved URLs or domains to be used for redirection.", 'Agility': 'Input validation can be carried out in different ways, using white- or blacklists. As described above, whitelisting is the recommended strategy. The exact strategy has to be defined for the respective system. To avoid inconsistencies, this should be done one-time for the developed system. In every increment handling redirects, the strategy must not be bypassed but used in the correct way. Independent of that, the strategy has to be maintained continuously, including new appearing security threats.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining input validation strategy', 'ActionPI': 'Correct use of strategy', 'ActionCo': 'Maintaining strategy', 'Verification': 'Using a MAR, the definition of the input validation strategy can be verified.\\\\The correct implementation of the strategy can be tested in multiple ways. Using ACA, the input validation operation (e.g. matching a whitelist) can be marked as sanitizing operation. Then, operations not using the strategy can be detected as unsanitized taint flow. Also, the correct use can be reviewed targeted in a MCR. An AVS or a MPT are only able to detect the result of a missing or incorrect use of the strategy (the weakness itself).\\\\ The maintenance of the strategy cannot be verified directly. It is conceivable to create a recurring reminder task in the used project management tool as MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['601'], 'Phases': ['Implementation']}, '47': {'Name': 'Static External Commands', 'Effectiveness': '', 'Description': 'If possible, ensure that all external commands called from the program are statically created.', 'Agility': 'This specific measure has to be considered during the  implementation phase: In increments calling external commands, these commands have to be statically created.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Creating static commands', 'ActionCo': '', 'Verification': 'To verify external commands are statically created has to be done using a whitebox method. With dynamic methods like MPT or AVS, only the presence of the vulnerability itself can be detected. Therefore, ACA or MCR are applicable for this measure.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['77'], 'Phases': ['Implementation']}, '48': {'Name': 'Use Sandbox or Jail', 'Effectiveness': 'Limited', 'Description': 'Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.', 'Agility': 'This is a one-time measure, establishing a sandbox solution for mitigating possible attacks on the operation system.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Establishing sandbox solution', 'ActionPI': '', 'ActionCo': '', 'Verification': 'The design of the sandbox solution can be reviewed in a MAR, the technical establishment has to be done in a MOC.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['22', '78'], 'Phases': ['Architecture and Design', 'Operation']}, '50': {'Name': 'Separate Code And Data', 'Effectiveness': '', 'Description': 'If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using exec or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]', 'Agility': 'By separating code and data for database calls, SQL injections can be prevented. This has to be done during the implementation of the single increments containing database access. If the language or the platform being used does not support such mechanisms, a library or framework has to be used (see \\ownref{M-4})', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Using structured mechanisms', 'ActionCo': '', 'Verification': 'The use of the structured mechanisms can be verified in multiple ways: Using an ACA, the structured mechanisms function as sanitizing operations. In a MCR, the usage can be reviewed directly. Using dynamic approaches can only discover the weakness (SQL Injection) itself, not the usage of the mechanisms. Anyhow, AVS and MPT are suitable to find these vulnerability.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['89'], 'Phases': ['Architecture and Design']}, '53': {'Name': 'Store Passwords Hashed', 'Effectiveness': '', 'Description': 'Consider storing cryptographic hashes of passwords as an alternative to storing in plaintext.', 'Agility': 'Assuming the hash functions have already selected (see \\ownref{M-39}), this measure is targeted on every increment storing passwords.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Storing password as hashes', 'ActionCo': '', 'Verification': 'The hashed storage of passwords can only be detected using in a white-box test. With a MCR, the measure is easily verifiable, and some ACA tools can also detect the storage of unhashed passwords (after doing some manually customizing)', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['256'], 'Phases': ['Architecture and Design']}, '55': {'Name': 'Proper Encryption', 'Effectiveness': '', 'Description': 'Ensure that encryption is properly integrated into the system design, including but not necessarily limited to: Encryption that is needed to store or transmit private data of the users of the system Encryption that is needed to protect the system itself from unauthorized disclosure or tampering Identify the separate needs and contexts for encryption: One-way (i.e., only the user or recipient needs to have the key). This can be achieved using public key cryptography, or other techniques in which the encrypting party (i.e., the software) does not need to have access to a private key. Two-way (i.e., the encryption can be automatically performed on behalf of a user, but the key must be available so that the plaintext can be automatically recoverable by that user). This requires storage of the private key in a format that is recoverable only by the user (or perhaps by the operating system) in a way that cannot be recovered by others. Using threat modeling or other techniques, assume that data can be compromised through a separate vulnerability or weakness, and determine where encryption will be most effective. Ensure that data that should be private is not being inadvertently exposed using weaknesses such as insecure permissions (CWE-732). [REF-7]', 'Agility': 'This high-level measure demanding "proper authentication" has multiple entry points in agile processes. Firstly, the encryption measures used have to be defined in a one-time action including risk-focused techniques like threat modeling. The correct use of the defined measures is important in every increment concerning encryption, and the changed attack surface of the system has to be taken into account to adjust the defined measures.  The selection, usage and monitoring of the encryption algorithms themselves is part of \\ownref{M-38}.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining encryption measures', 'ActionPI': 'Correct use of measures', 'ActionCo': '', 'Verification': 'Verifying the definition of encryption measures has to be done in a MAR.\\\\The detection of the correct use of the those measures highly depends on the measures. While a MCR is surely possible, SCA may not be applicable here. Dynamic techniques like AVS or a MPT are likely not to be able to verify this measure.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['311', '312'], 'Phases': ['Architecture and Design']}, '56': {'Name': 'Use SSL for Entire Session', 'Effectiveness': '', 'Description': 'When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page.', 'Agility': 'Establishing SSL for the entire session is a one-time task to be carried out for this measure.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Using SSL for entire session', 'ActionPI': '', 'ActionCo': '', 'Verification': 'Using SSL for the entire session can be verified with dynamic tools as AVS or a MPT. Using static tools may be possible, too, but entails the risk the encryption does not work properly in the running system', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '1', 'MCR_OT': '0', 'AVS_OT': '3', 'MPT_OT': '3', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['319'], 'Phases': ['Implementation']}, '57': {'Name': 'Use Double Cookie', 'Effectiveness': '', 'Description': "For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.", 'Agility': 'This measure prevents Session Fixation flaws. Every increment issuing new sessions has to follow this measure (if the platform does not generate a new session id).', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Using double cookie', 'ActionCo': '', 'Verification': 'The use of a secondary cookie can be detected both in static and dynamic approaches, but needs a human contribution. Therefore, MCR and MPT are recommended to verify this measure. For automation, the creation of a custom test case as CAT, checking the utilization of a secondary cookie is conceivable.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '3', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['384'], 'Phases': ['Architecture and Design']}, '58': {'Name': 'Appropriate Cryptography Usage', 'Effectiveness': '', 'Description': 'Make appropriate use of cryptography to protect the credentials.', 'Agility': 'This high-level measure demands the selection of suitable cryptography in the first place. In every increment handling credentials, the defined cryptography has to be used accordingly. As with all cryptographic functions, their up-to-dateness has to be checked continuously.', 'Source': 'CWE', 'Comment': 'Very unspecific', 'ActionOT': 'Selection of cryptography mechanism', 'ActionPI': 'Correct usage of cryptography mechanism', 'ActionCo': 'Monitoring of cryptography mechanism', 'Verification': 'The choice of cryptographic algorithms use has to be evaluated in a MAR.\\\\ To ensure the appropriate use of cryptography, white-box test have to be carried out. With customization, an ACA can be trained to discover unsafe handling of credential, but cannot decide whether it is appropriate. This is possible in a MCR. \\\\The monitoring of the mechanism is not verifiable directly, but it is conceivable to create a recurring reminder\ntask in the used project management tool as MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['522'], 'Phases': ['Architecture and Design']}, '61': {'Name': 'Secure Forgotten Password Process', 'Effectiveness': '', 'Description': 'Do not use forgotten password functionality. But if you must, ensure that you are only providing information to the actual user, e.g. by using an email address or challenge question that the legitimate user already provided in the past; do not allow the current user to change this identity information until the correct password has been provided.', 'Agility': 'Designing a proper process for a password change is content of this measure. It is typically done in one particular increment.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Designing proper process', 'ActionCo': '', 'Verification': 'The verification of this measure requires to decide if a process is designed securely. This has to be done in a MAR.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '3', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['620'], 'Phases': ['Architecture and Design']}, '62': {'Name': 'Adequate Security Question', 'Effectiveness': '', 'Description': 'Do not use standard weak security questions and use several security questions.', 'Agility': 'This measure is strongly connected with \\ownref{M-61} demanding the selection of adequate security questions.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Selecting adequate questions', 'ActionCo': '', 'Verification': 'To verify this measure, the security questions have to be assessed in a MAR.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '3', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['640'], 'Phases': ['Architecture and Design']}, '63': {'Name': 'Appropiate Encoding', 'Effectiveness': '', 'Description': 'Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies. For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters. Parts of the same output document may require different encodings, which will vary depending on whether the output is in the: HTML body Element attributes (such as src=XYZ) URIs JavaScript sections Cascading Style Sheets and style property etc. Note that HTML Entity Encoding is only appropriate for the HTML body. Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.', 'Agility': 'For preventing XSS, this measure recommends to define an encoding strategy containing the different kind of data, the way they are used in the software and which kind of encoding is appropriate. This should be done consistently once for the development project. Every increment processing output data has to follow this strategy and implement the fitting encoding.  Additionally, the strategy has to be maintained continuously, reacting to new appearing security threats.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining encoding strategy', 'ActionPI': 'Correct use of strategy', 'ActionCo': 'Maintaining strategy', 'Verification': 'Using a MAR, the definition of the encoding strategy can be verified.\\\\ The correct implementation of the strategy can be tested in multiple ways. Using ACA, the encoding operation can be marked as sanitizing operation. Then, operations not using the strategy can be detected as unsanitized taint flow. Also, the correct use can be reviewed targeted in a MCR. An AVS or a MPT are only able to detect the result of a missing or incorrect use of the strategy (the weakness itself).\\\\ The maintenance of the strategy cannot be verified directly. It is conceivable to create a recurring reminder task in the used project management tool as MOC. ', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['79'], 'Phases': ['Architecture and Design', 'Implementation']}, '64': {'Name': 'Server-side Checks', 'Effectiveness': '', 'Description': 'For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.', 'Agility': 'Every increment containing client-side checks has to ensure that those are performed server-side, too, if they are not just convenience but a security measure.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing server-side checks', 'ActionCo': '', 'Verification': 'The implementation of this measure has to be verified in a manual way as client-side checks usually involve business logic not suitable for automated tools. With MCR, the existence of the tests can be checked directly in the code, while a MPT would verify that even when manipulating request after the client checks, the server detects the maliciousness. This can be automated by writing manual testcases verifying that malicious data is rejected by server-side checks.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '3', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['22', '78', '79', '89'], 'Phases': ['Architecture and Design']}, '66': {'Name': 'Avoid User-Controlled Key', 'Effectiveness': '', 'Description': "Make sure that the key that is used in the lookup of a specific user's record is not controllable externally by the user or that any tampering can be detected.", 'Agility': 'This measure requires the design of a secure lookup of users. As this is often an operation affecting multiple increments, designing this lookup is a one-time action for the entire development project.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Designing secure user lookup', 'ActionPI': '', 'ActionCo': '', 'Verification': 'The design of a secure user lookup has to be verified doing a MAR.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['639'], 'Phases': ['Architecture and Design', 'Implementation']}, '68': {'Name': 'Correct Compiler Configuration', 'Effectiveness': '', 'Description': 'If possible, configure your compiler so that it does not remove dead stores.', 'Agility': 'In modern development projects, the configuration of the development environment and the build is shared and standardized. This compilation-specific measure should be considered when designing the build of the software (e.g. using a build tool).', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Configuring compiler correctly', 'ActionPI': '', 'ActionCo': '', 'Verification': 'This measure is affecting build and compilation. The check of the build configuration can be carried out manually as a MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['14'], 'Phases': ['Build and Compilation']}, '69': {'Name': 'Secure Exception Handling', 'Effectiveness': '', 'Description': 'Handle exceptions internally and do not display errors containing potentially sensitive information to a user.', 'Agility': 'This measure has to be considered in every increment handling exceptions.  It neither requires preliminary actions nor continuous monitoring. ', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Handling exceptions internally', 'ActionCo': '', 'Verification': 'This measure can be verified by multiple methods: Both manual test approaches, MCR and MPT can cover the verification of an internally exception handling. An ACA can detect when sensitive information are exposed in an error message, as well as a AVS can detect potentially verbose error messages. For automation, a human interpretation of the exposed information is necessary. ', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '3', 'AVS_PI': '1', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['209'], 'Phases': ['Implementation']}, '70': {'Name': 'Define Trust Boundaries', 'Effectiveness': '', 'Description': 'Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.', 'Agility': 'Dividing the system into different areas with trust boundaries is difficult in agile development projects as the individual components emerge and  grow over time. Therefore, in agile projects, the initial measure is to define a framework of categories of areas and trust boundaries in the beginning. During each increment this model has to be adapted and the compliance with the trust boundaries has to be checked.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining trust boundaries', 'ActionPI': 'Following trust boundaries', 'ActionCo': '', 'Verification': 'A MAR can be used to verify the definition of the trust zones.\\\\ The use of trust boundaries is highly depending on the kind of data used and the underlying business logic. Therefore, automated verification is hard to achieve. Suitable verification methods are therefore MCR and, for detecting breaches in the trust boundaries, MPT. It may be possible to transfer single properties into test cases as CAT and execute them automated in the build pipeline.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '1', 'CAT_PI': '1', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['215', '311', '312'], 'Phases': ['Architecture and Design']}, '79': {'Name': 'Correct Entity Authentication', 'Effectiveness': '', 'Description': 'Understand and properly implement all checks necessary to ensure the identity of entities involved in encrypted communications.', 'Agility': 'This rather unspecific measure relates to the use of encrypted communications in the implementation phase. In every such increment, the necessary checks have to be implemented.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing checks', 'ActionCo': '', 'Verification': 'Itâ€™s hard to assign verification methods to this unspecific method. As it affects the implementation of checks, a MCR should be a suitable verification method.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['322'], 'Phases': ['Implementation']}, '80': {'Name': 'Implement Unique Nonces', 'Effectiveness': '', 'Description': 'Use techniques such as requiring incrementing, time based and/or challenge response to assure uniqueness of nonces.', 'Agility': 'This specific measure recommends different techniques to ensure the uniqueness of a nonce. This has to be considered in every increment regarding implementing nonces.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing unique nonces', 'ActionCo': '', 'Verification': 'To verify this implementation measure, a MCR can be performed. Using black-box tests, it may be possible to recognize the used method for generating nonces (incrementing/timestamps) in a MPT. An automation of the verification is complicated as the creation of nonces is not transparent.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '1', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['323'], 'Phases': ['Implementation']}, '84': {'Name': 'Interchangeable Cryptography', 'Effectiveness': '', 'Description': 'Design the software so that one cryptographic algorithm can be replaced with another. This will make it easier to upgrade to stronger algorithms.', 'Agility': "As agile developed software is under continuous change, it is often the case that components have to be upgraded or switched. Therefore, modularity of a system and the easily possible interchangeability of parts of it is a common characteristic in agile projects. That's why the design of an interchangeable cryptography is quite possible. It has to be done once at an early stage of the project. ", 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Designing interchangeable cryptography', 'ActionPI': '', 'ActionCo': '', 'Verification': 'This measure can only be verified with a MAR as it only affects the design of the system.', 'VerificationSource': '', 'Type': ' Other ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['327'], 'Phases': ['Architecture and Design']}, '89': {'Name': 'Business Logic Related Checks', 'Effectiveness': '', 'Description': "Ensure that you perform access control checks related to your business logic. These checks may be different than the access control checks that you apply to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor.", 'Agility': 'Firstly, an initial framework for access control has to be defined and technologically established. As the business logic changes over time just like other requirements, every increment regarding such changes has to adapt this rule set, and apply it correctly to the respective implementation.as well as', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining access control', 'ActionPI': 'Applying correct access rules or add new', 'ActionCo': '', 'Verification': 'As the measureâ€™s title indicates, it is depending on business logic. Thatâ€™s why verification is possible in a manual way, but difficult with dynamic approaches. The definition has therefore be checked in a MAR. \\\\For the single increments, a MCR or a MPT can be verifying methods. Single scenarios may be transferable into custom testcases as CAT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '1', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['285'], 'Phases': ['Architecture and Design']}, '91': {'Name': 'Ensure Absence of XSS', 'Effectiveness': '', 'Description': 'Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script.', 'Agility': 'This measure is related to the complete weakness XSS \\ownref{W-79}. The absence of XSS flaws has to be checked and monitored, when no measure according to \\ownref{CWE-79} is used.', 'Source': 'CWE', 'Comment': 'Unusual mititgation as refering to other vulnerability', 'ActionOT': '', 'ActionPI': '', 'ActionCo': 'Ensuring XSS-free application', 'Verification': 'The absence of XSS should be ensured by measures regarding \\ownref{CWE-79}. A continuous monitoring regarding XSS can be done by a ACA or AVS solution which are integrated into the build pipeline. Manual methods are possible, too, but are not effective in a continuous use.', 'VerificationSource': '', 'Type': ' Other ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '3', 'MCR_Co': '1', 'AVS_Co': '3', 'MPT_Co': '1', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['352'], 'Phases': ['Implementation']}, '92': {'Name': 'Use Intermediate Page', 'Effectiveness': '', 'Description': 'Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE-79) when generating the disclaimer page.', 'Agility': 'The design of a redirect with intermediate page has to be done once for a consistent use in the application development. Every increment using redirects has to use the established intermediate concept and must not bypass it.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Designing intermediated redirect', 'ActionPI': 'Using intermediate redirect', 'ActionCo': '', 'Verification': 'With a MAR, the design of the mechanism for intermediate pages can be verified. \\\\The implementation of the intended mechanism can done by MCR or MPT, and, if a customized sanitizer is added, with a taint flow analysis in ACA.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['601'], 'Phases': ['Architecture and Design']}, '94': {'Name': 'Minimize User-Controlled Commands', 'Effectiveness': '', 'Description': "For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session's state instead of sending it out to the client in a hidden form field.", 'Agility': 'This measure has to be applied in every increment handling commands based on user data. It does not require preliminary actions or continuous monitoring. ', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing with minimized user-controlled commands', 'ActionCo': '', 'Verification': 'This measure is hard to verify as â€œminimizedâ€ user-controlled commands is a diffuse term that requires human interpretation. That is only possible in manual test as MCR and MPT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['78'], 'Phases': ['Architecture and Design']}, '95': {'Name': 'Convert Data Types', 'Effectiveness': '', 'Description': "Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.", 'Agility': 'The (manual) conversion of input into the correct data type as recommended in this measure has to be done in every increment handling such data. A preparing one-time action or continuous activities are not necessary.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing conversions', 'ActionCo': '', 'Verification': 'The correct conversion of data types can only be verified with a white-box MCR.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['88'], 'Phases': ['Implementation']}, '96': {'Name': 'Run at Least Privilege', 'Effectiveness': '', 'Description': "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.", 'Agility': 'This mitigating measure needs a one-time action to create the runtime concept defining the different accounts needed as well as the (minimal) rights granted to them. Every increment affecting operations defined to be done by special accounts has to consider this concept. Additionally, the accounts or the rule set has to be adjusted if necessary.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Designing runtime concept', 'ActionPI': 'Following runtime concept', 'ActionCo': '', 'Verification': 'The definition of the runtime concept can be verified using MAR. \\\\The correct realization of this concept is hard to verify, as itâ€™s effects are only visible at runtime, but dynamic methods cannot evaluate the rights the code is running with. Therefore, this measure has to be verified using manual checks in the operation phase, assessing the configuration.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '3', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['89'], 'Phases': ['Architecture and Design', 'Operation']}, '99': {'Name': 'Prohibit Unsecure Encoding', 'Effectiveness': 'None', 'Description': 'A programmer might attempt to remedy the password management problem by obscuring the password with an encoding function, such as base 64 encoding, but this effort does not adequately protect the password because the encoding can be detected and decoded easily.', 'Agility': 'In increments implementing the storage of passwords, developers must not obscure them insufficiently by a reversible encoding.', 'Source': 'CWE', 'Comment': 'Awareness/Training', 'ActionOT': '', 'ActionPI': 'Do not use secure encoding', 'ActionCo': '', 'Verification': 'The use of insecure encoding can be detected by static tools: With ACA taint analysis, unsecure encoding is not detected as sanitizing operation. In a MCR, the unsecure encoding can be found as well. ', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['256'], 'Phases': ['Implementation']}, '102': {'Name': 'Perform Dynamic Analysis', 'Effectiveness': '', 'Description': 'Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.', 'Agility': 'This atypical measure is more a detection than a preventing or mitigation method. It has to be carried out continuously.', 'Source': 'CWE', 'Comment': 'Less Mitigation than Detection', 'ActionOT': '', 'ActionPI': '', 'ActionCo': 'Continuous testing', 'Verification': 'This atypical measure directly refers to MPT as detecting methods.', 'VerificationSource': '', 'Type': ' Detection ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '3', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['319'], 'Phases': ['Testing']}, '104': {'Name': 'Use Industry Standards', 'Effectiveness': '', 'Description': 'Use industry standards to protect the credentials (e.g. LDAP, keystore, etc.).', 'Agility': 'In increments handling credentials, industry standards according to this measure should be used. This measure has to be seen together with \\ownref{M-12} and \\ownref{M-58}', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Using standards', 'ActionCo': '', 'Verification': 'The use of standards has to be verified in a MCR. ACA or dynamic approaches are not applicable here.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['522'], 'Phases': ['Implementation']}, '108': {'Name': 'Limit Number of Attempts', 'Effectiveness': '', 'Description': 'Make sure that there is throttling on the number of incorrect answers to a security question. Disable the password recovery functionality after a certain (small) number of incorrect guesses.', 'Agility': 'This measure recommends a property for a secure password recovery process. Increments implementing this process should include the limitation of number of incorrect guesses. ', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Limiting number of attempts', 'ActionCo': '', 'Verification': 'The limited number of attempts can be verified in a MCR, but also in a MPT. Automated tools as ACA or AVS are not usable as the specific number of attempts depends on the logic of the application. However, manual testcases verifying the limitation are easily feasible.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '3', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['640'], 'Phases': ['Architecture and Design']}, '109': {'Name': 'Well-defined interfaces', 'Effectiveness': 'Limited', 'Description': 'Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.', 'Agility': 'This measure has more the character of awareness/training than a preventing or mitigating measure. In the concrete development process, it has to be involved in every single increment by taking into account the implications on the attack surface. As the measure enumerates, this is not limited to parameters or arguments.', 'Source': 'CWE', 'Comment': 'Awareness/Training', 'ActionOT': '', 'ActionPI': 'Understanding changed attack surface', 'ActionCo': '', 'Verification': 'This measure is not explicitly verifiable.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['79'], 'Phases': ['Architecture and Design', 'Implementation']}, '110': {'Name': 'Decode Path Names Before Validation', 'Effectiveness': '', 'Description': "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked. Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes .. sequences and symbolic links (CWE-23, CWE-59). This includes: realpath() in C getCanonicalPath() in Java GetFullPath() in ASP.NET realpath() or abs\\_path() in Perl realpath() in PHP", 'Agility': 'This measure affects all increments handling pathnames. Before validating the pathname(see \\ownref{M-18}), it has to be decoded and canonicalized.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing decoding', 'ActionCo': '', 'Verification': 'The implementation of this measure has to be verified using a MCR. ACA or dynamic approaches are not applicable here.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['22'], 'Phases': ['Implementation']}, '112': {'Name': 'Encrypt or Sign User Keys', 'Effectiveness': '', 'Description': 'Use encryption in order to make it more difficult to guess other legitimate values of the key or associate a digital signature with the key so that the server can verify that there has been no tampering.', 'Agility': 'By encrypting or signing the user key, tampering can be avoided or detected. In order to ensure a consistent format of user-controlled keys, it has to be defined in a one-time action beforehand. Then, every increment handling such data has to follow the defined format.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Designing format of user keys', 'ActionPI': 'Correct use of design', 'ActionCo': '', 'Verification': 'The design of the protection of user keys can be reviewed in a MAR. \\\\For verifying its realization, a MCR can be performed. The encryption or signature of keys are also visible in a MPT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['639'], 'Phases': ['Architecture and Design']}, '114': {'Name': 'Encrypt Sensitive Data', 'Effectiveness': '', 'Description': 'Where possible, encrypt sensitive data that are used by a software system.', 'Agility': 'By encrypting sensitive data used in the application, it cannot be used even if the clearing of buffers fails. This has to be done in increments handling such data. The selection and usage of the encryption algorithms themselves is part of another measure (see \\ownref{M-38}).', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Encrypting sensitive data', 'ActionCo': '', 'Verification': 'The verification of this measure requires human interpretation if data is sensitive or not. As the measure relates to encryption inside of the code, a MCR is suitable for verifying.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['14'], 'Phases': ['Architecture and Design']}, '115': {'Name': 'Use Naming Conventions', 'Effectiveness': 'Defense in Depth', 'Description': 'Use naming conventions and strong types to make it easier to spot when sensitive data is being used. When creating structures, objects, or other complex entities, separate the sensitive and non-sensitive data as much as possible.', 'Agility': 'The use of naming conventions require the existence of such rules in the first place. Therefore, these have to be define beforehand. Every increment has to follow these naming conventions correctly. ', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining naming conventions', 'ActionPI': 'Following naming conventions', 'ActionCo': '', 'Verification': 'Checking the established naming conventions is similar to a MAR, but as it does not affect the architecture itself, but the development environment, it is classified as a MOC here.\\\\The compliance to this conventions can be verified partly automated, as modern development projects already perform checks regarding coding guidelines and naming conventions. But these checks cannot distinguish what variable contains sensitive data or not, so MCR is a necessary addition.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['209', '311', '312'], 'Phases': ['Implementation']}, '130': {'Name': 'Key Management', 'Effectiveness': '', 'Description': 'Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant.', 'Agility': 'A careful handling of cryptographic keys requires the establishment of a key management at an early stage of development, including plans for protecting the keys. An increment handling such cryptographic keys has to follow the defined strategy. The management strategy has to be under continuous monitoring to ensure the keys are constantly well protected and of adequate strength.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Establishing key management', 'ActionPI': 'Following key management', 'ActionCo': 'Maintaining keys', 'Verification': 'The definition of the key management strategy can be verified using a MAR.\\\\The correct implementation of the strategy depends on the concrete content. Usually, a MCR is the applicable verification method for this measure.\\\\ The maintenance of the keys cannot be verified directly. It is conceivable to create a recurring reminder task in the used project management tool as MOC.', 'VerificationSource': '', 'Type': ' Other ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['327'], 'Phases': ['Architecture and Design']}, '135': {'Name': 'Use of Library or Framework', 'Effectiveness': '', 'Description': 'Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].', 'Agility': 'The selection of the library or framework handling the authorization has to be done once at an early stage of the development. In every increment involving authorization the library/framework has to be used in a correct way. As with all external dependencies, the library or framework has to be kept up-to-date regarding updates and patches.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Selection of library/framework', 'ActionPI': 'Correct use of library/framework', 'ActionCo': 'Monitoring of library/framework', 'Verification': 'The selection of an appropriate library or framework can be verified in a MAR. \\\\ The correct use of the selected solution can be verified performing a MCR. An AVS or a MPT are only able to detect authorization vulnerabilities as a result of a missing or incorrect use of the library/framework. \\\\ The library or framework can be monitored using an ADC. ', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '3', 'MOC_Co': '0', 'Weaknesses': ['285'], 'Phases': ['Architecture and Design']}, '137': {'Name': 'Use Submit Nonce', 'Effectiveness': '', 'Description': 'Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]', 'Agility': 'This measure gives a detailed implementation advice about avoiding CSRF vulnerabilities. It has to be considered in every increment handling form requests, but does not require preliminary actions.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing form nonce', 'ActionCo': '', 'Verification': 'This measure can be verified in a MCR or in a MPT, whereby the latter cannot verify the uniqueness of the nonce. ACA or AVS cannot detect this measure properly.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['352'], 'Phases': ['Architecture and Design']}, '138': {'Name': 'Restrict and Enumerate Objects', 'Effectiveness': '', 'Description': 'When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to /login.asp and ID 2 could map to http://www.example.com/. Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.', 'Agility': 'The mapping between the target URLs or filenames and the IDs has to be created once in the beginning. In every increment handling redirects, this mapping has to be used correctly, eventually a new entry has to be added to the map.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Establishing object map', 'ActionPI': 'Correct use of map and extending it', 'ActionCo': '', 'Verification': 'The establishment of the mapping consists of its design what can be checked in a MAR, and the technological implementation. The latter has to be verified in a MCR. \\\\The correct use of the mapping can be checked in multiple ways. Firstly, a MCR can verify if it is implemented correctly. Secondly, when defining the mapping as sanitizing operation, a ACA can reveal redirects not using the map. Lastly, a MPT may distinguish between open redirects and enumerated target objects, depending on the implementation.\n', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '3', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '1', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['601'], 'Phases': ['Architecture and Design']}, '139': {'Name': 'Use Whitelist Policy', 'Effectiveness': '', 'Description': 'Run time: Run time policy enforcement may be used in a whitelist fashion to prevent use of any non-sanctioned commands.', 'Agility': 'The runtime policy has to be established once as a whitelist of allowed commands. Every increment using new commands has to extend the whitelist.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Establishing Runtime Policy Enforcement', 'ActionPI': 'Extending whitelist if necessary', 'ActionCo': '', 'Verification': 'The runtime policy has to be established once as a whitelist of allowed commands. Every increment\nusing new commands has to extend the whitelist.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['77'], 'Phases': ['Operation']}, '141': {'Name': 'Decode Inputs Before Validation', 'Effectiveness': '', 'Description': "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control. Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.", 'Agility': 'This measure affects all increments handling arguments. Before validating the arguments (see \\ownref{M-5}), they have to be decoded and canonicalized.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing decoding', 'ActionCo': '', 'Verification': 'The implementation of this measure has to be verified using a MCR. ACA or dynamic approaches are not applicable here.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['88'], 'Phases': ['Implementation']}, '148': {'Name': 'Configure Server Communication', 'Effectiveness': '', 'Description': 'Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols.', 'Agility': 'This security measure is a one-time action based in the Operation phase.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Configuring SSL communications', 'ActionPI': '', 'ActionCo': '', 'Verification': 'This measure can be verified by dynamic approaches: A AVS as well as a MPT can check if the application communicates encrypted. In addition, a MOC reviewing the server configuration is possible', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '3', 'MPT_OT': '3', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['319'], 'Phases': ['Operation']}, '154': {'Name': 'Check Answers to Security Questions', 'Effectiveness': '', 'Description': 'Require that the user properly answers the security question prior to resetting their password and sending the new password to the e-mail address of record.', 'Agility': 'This measure affects the correct implementation of a password recovery process. It has to be considered in the increment covering the password recovery.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing security questions correctly', 'ActionCo': '', 'Verification': 'The correct implementation of this measure can be verified using a MCR or in a MPT. As the answering to security questions needs human guidance, automation is only possible by creating custom test cases as CAT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '3', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['640'], 'Phases': ['Architecture and Design']}, '156': {'Name': 'Use of Library or Framework', 'Effectiveness': '', 'Description': 'Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.', 'Agility': 'The selection of the library handling file system access has to be done once according to the particular requirements. This library has to be used correctly in each increment involving command calls (and has to be used in the first place). As with all external dependencies, the library has to be kept up-to-date regarding updates and patches.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Selection of library/framework', 'ActionPI': 'Correct use of library/framework', 'ActionCo': 'Monitoring of library/framework', 'Verification': 'The selection of an appropriate library or framework can be verified in a MAR. \\\\The correct use of the selected solution can be tested in multiple ways. Using ACA, the library/framework can be marked as sanitizing operation. Then, operations not using the library/framework can be detected as unsanitized taint flow. Also, the correct use can be reviewed targeted in a MCR. An AVS or a MPT are only able to detect the result of a missing or incorrect use of the library/framework (the weakness itself).\\\\ The library or framework can be monitored using an ADC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '3', 'MOC_Co': '0', 'Weaknesses': ['22'], 'Phases': ['Architecture and Design']}, '161': {'Name': 'Remove Debug Information', 'Effectiveness': '', 'Description': 'Debugging information should not make its way into a production release.', 'Agility': 'When setting up the release strategy, i.e. establishing a continuous deployment pipeline, a step for the removal of debug statements has to be integrated. Such removal can be automatic in common CD-tools.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Ensuring automatic removal', 'ActionPI': '', 'ActionCo': '', 'Verification': 'The automatic removal of debug information during the build process has to be checked manually examining the CD-pipeline as MOC. Beside that, the effect of not removing such information may be detected by AVS or MPT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '2', 'MPT_OT': '2', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['209'], 'Phases': ['Implementation', 'Build and Compilation']}, '176': {'Name': 'Use of Library or Framework', 'Effectiveness': '', 'Description': 'Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Industry-standard implementations will save development time and may be more likely to avoid errors that can occur during implementation of cryptographic algorithms. Consider the ESAPI Encryption feature.', 'Agility': 'The selection of the library or framework containing the cryptography has to be done once according to the particular requirements. This library has to be used correctly in each increment involving command calls (and has to be used in the first place). As with all external dependencies, the library has to be kept up-to-date regarding updates and patches.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Selection of library/framework', 'ActionPI': 'Correct use of library/framework', 'ActionCo': 'Monitoring of library/framework', 'Verification': 'The selection of an appropriate library or framework can be verified in a MAR. \\\\ The correct use of the selected solution can be verified performing a MCR. Using automated or dynamic approaches, a verification of using the right cryptographic library/framework is hardly possible.\\\\ The library or framework can be monitored using an ADC. ', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '3', 'MOC_Co': '0', 'Weaknesses': ['325', '327'], 'Phases': ['Architecture and Design']}, '181': {'Name': 'Server-Side Access Control', 'Effectiveness': '', 'Description': 'For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page. One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.', 'Agility': 'In the first place, an authentication strategy limiting the access to certain pages has to be established. Every increment has to ensure a correct realization of the strategy.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Designing authentication concept', 'ActionPI': 'Correct realization', 'ActionCo': '', 'Verification': 'The design of the authentication can be reviewed in a MAR. \\\\ Verifying its realization is possible in multiple ways: Using MCR can check the implementation in the code base. Using a MPT, the real effects on the application, the precise access control can be evaluated. As this access control is always related to business logic, these verifications are difficult to automate.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['285'], 'Phases': ['Architecture and Design']}, '183': {'Name': 'Confirm for Relevant Operations', 'Effectiveness': '', 'Description': 'Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.', 'Agility': 'This measure has to be considered in each increment introducing a dangerous situation.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing confirmation request', 'ActionCo': '', 'Verification': 'This measure has to be verified in a manual way. Either its code realization can be checked using a MCR, or a MPT is used to verify the complete process of confirmation. For automation, the creation of a custom test case per relevant operation as CAT can check for the confirmation dialogue.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '3', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['352'], 'Phases': ['Architecture and Design']}, '184': {'Name': 'Use Nonce for Redirect Requests', 'Effectiveness': '', 'Description': 'Ensure that no externally-supplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF-483]. Be sure that the nonce is not predictable (CWE-330).', 'Agility': 'The implementation of a unique nonce for every redirect has to be done in the increments handling redirects which can be controlled from external.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing nonce', 'ActionCo': '', 'Verification': 'This measure can be verified in a MCR or in a MPT, whereby the latter cannot verify the uniqueness of the nonce. ACA or AVS cannot handle this measure properly.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['601'], 'Phases': ['Architecture and Design']}, '185': {'Name': 'File Access Control', 'Effectiveness': '', 'Description': 'Assign permissions to the software system that prevents the user from accessing/opening privileged files.', 'Agility': 'This measure can mitigate the impact of a command injection if an attacker cannot access certain privileged files. These files and their access rights have to be defined beforehand, and every increment handling file access has to follow this concept.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining privileged files ', 'ActionPI': 'Comply with file concept', 'ActionCo': '', 'Verification': 'The verification of the definition of the file access control has to be performed in a MAR.\\\\ The detection of the correct implementation can be done in a MCR or MPT, but also automated in a manually written testcase as CAT.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '3', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['77'], 'Phases': ['System Configuration']}, '186': {'Name': 'Use of Library or Framework', 'Effectiveness': '', 'Description': 'Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.', 'Agility': 'The selection of the library or framework has to be done once at an early stage of the development. In every increment involving OS commands, the library/framework has to be used in a correct way. As with all external dependencies, the library or framework has to be kept up-to-date regarding updates and patches.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Selection of library/framework', 'ActionPI': 'Correct use of library/framework', 'ActionCo': 'Monitoring of library/framework', 'Verification': 'The selection of an appropriate library or framework can be verified in a MAR. \\\\The correct use of the selected solution can be tested in multiple ways. Using ACA, the library/framework can be marked as sanitizing operation. Then, operations calling OS commands not using the library/framework can be detected as unsanitized taint flow. Also, the correct use can be reviewed targeted in a MCR. An AVS or a MPT are only able to detect the result of a missing or incorrect use of the library/framework (the weakness itself).\\\\ The library or framework can be monitored using an ADC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '3', 'MOC_Co': '0', 'Weaknesses': ['78'], 'Phases': ['Architecture and Design']}, '187': {'Name': 'Ensure Identical Encoding', 'Effectiveness': '', 'Description': 'When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.', 'Agility': 'In order to have a common encoding used across components, this encoding has to be defined on a higher level. Increments affecting components exchanging data have to use the defined encodings correctly.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining common used encoding', 'ActionPI': 'Use defined encoding', 'ActionCo': '', 'Verification': 'The definition of a common encoding has to be verified in a MAR.\\\\ A MCR is the only applicable method to verify the encoding is used in both components.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['88'], 'Phases': ['Implementation']}, '188': {'Name': 'Encode Output Using Whitelist', 'Effectiveness': '', 'Description': 'While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88). Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS\\_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql\\_real\\_escape\\_string() API function is available in both C and PHP.', 'Agility': 'This measure differs from the use of a pre-defined whitelist (see \\ownref{M-234}) as targets a single increment. It recommends the manual neutralization of malicious elements in user input used for generating the SQL command. This has to be done in every increment, strictly customized to the allowed characters in the special usecase.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Correct use of whitelist', 'ActionCo': '', 'Verification': 'While the use of output encoding can be verified in MCR and, if the encoding functionality is defined as sanitizing operation, can be automated in an ACA, this heavily depends on the correct whitelist. Here, it is more reliable to perform dynamic tests. AVS are well able to detect SQL Injection vulnerabilities, and a MPT using extensive payloads, too.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '1', 'AVS_PI': '3', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['89'], 'Phases': ['Implementation']}, '193': {'Name': 'Correct Use of External Techniques', 'Effectiveness': '', 'Description': "When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.", 'Agility': 'The correct, full usage of industry-approved techniques is part of every increment handling the encryption using these techniques.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Correct use of external techniques', 'ActionCo': '', 'Verification': 'Checking if external techniques are implemented correctly can only be done by precisely examining in the actual code, why a MCR is the applicable method for this measure.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['311', '312', '327'], 'Phases': ['Architecture and Design', 'Implementation']}, '200': {'Name': 'Unchangeable Recovery Address', 'Effectiveness': '', 'Description': 'Never allow the user to control what e-mail address the new password will be sent to in the password recovery mechanism.', 'Agility': 'This measure gives a detailed advice for increments implementing the password recovery. ', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing unchangeable address', 'ActionCo': '', 'Verification': 'Verifying this measure needs human intelligence as it affects a complex process. While it is possible to examine the code in a MCR whether the used e-mail address can be changed, it is recommended to perform a MPT. By that, the possibilities of an attacker controlling the address can be fully exploited.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '1', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['640'], 'Phases': ['Architecture and Design']}, '201': {'Name': 'Separate Code And Data', 'Effectiveness': '', 'Description': 'If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.', 'Agility': 'The separation of code and data can prevent XSS weaknesses. This has to be done during the implementation of the single increments handling user controlled output. If the used language or platform does not support such mechanisms, a library or framework has to be used (see \\ownref{M-17})', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Use structured mechanisms', 'ActionCo': '', 'Verification': 'The use of the structured mechanisms can be verified in multiple ways: Using an ACA, the structured mechanisms function as sanitizing operations. In a MCR, the usage can be reviewed directly. Using dynamic approaches can only discover the weakness (XSS) itself, not the usage of the mechanisms. Anyhow, AVS and MPT are suitable to find these vulnerability.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['79'], 'Phases': ['Architecture and Design']}, '202': {'Name': 'Use an Application Firewall', 'Effectiveness': 'Moderate', 'Description': 'Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.', 'Agility': 'An application firewall can mitigate the effects of multiple different weaknesses. It has to be established and configured as a one-time action. In every increment, the rules have to be adapted according to new interfaces or other changes. Additionally, it has to be continuously monitored during the development process to react on the transforming attack surface of the application or the changing threat situation.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Configuring application firewall', 'ActionPI': 'Adapting rules', 'ActionCo': 'Monitoring firewall', 'Verification': "To verify this mitigating measure, the set up of the application firewall has to be checked manually as a MOC. \\\\The adaption of the firewall's ruleset is only possible using another MOC. \\\\The monitoring of the firewall cannot be verified directly. It is conceivable to create a recurring reminder task in the used project management tool as a third MOC.", 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '3', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '3', 'Weaknesses': ['22', '78', '79', '89', '601'], 'Phases': ['Operation']}, '227': {'Name': 'Configure Server Access Control', 'Effectiveness': '', 'Description': 'Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a default deny policy when defining these ACLs.', 'Agility': 'The access control recommended by this measure has to be defined as a one-time action. In every increment affecting access rights on the operating system or in the server configuration, the defined rule set has to be followed.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining access control', 'ActionPI': 'Using access control', 'ActionCo': '', 'Verification': 'The verification of the definition of the access control can be performed in a MAR. \\\\The correct usage has to be checked using MCR.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['285'], 'Phases': ['System Configuration', 'Installation']}, '229': {'Name': 'Use Double Cookie', 'Effectiveness': '', 'Description': "Use the double-submitted cookie method as described by Felten and Zeller: When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same. Because of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult. This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF-331]", 'Agility': 'The double-submitted cookie has to be implemented in every increment containing a request done by form submission. ', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Using double cookie', 'ActionCo': '', 'Verification': 'The use of a double cookie can be verified by performing a MCR on the one hand or in a MPT on the other. For automation, the creation of a custom test case checking the presence of such a cookie is conceivable as CAT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '3', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['352'], 'Phases': ['Architecture and Design']}, '230': {'Name': 'Well-defined interfaces', 'Effectiveness': '', 'Description': 'Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.', 'Agility': 'This measure has more the character of awareness/training than a preventing or mitigating measure. In the actual development process, it has to be involved in every single increment handling redirects by taking into account the implications on the attack surface.', 'Source': 'CWE', 'Comment': 'Awareness/Training', 'ActionOT': '', 'ActionPI': 'Understanding changed attack surface', 'ActionCo': '', 'Verification': 'This measure is not explicitly verifiable.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['601'], 'Phases': ['Architecture and Design', 'Implementation']}, '232': {'Name': 'Encode Output Using Whitelist', 'Effectiveness': '', 'Description': 'While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).', 'Agility': 'This measure differs from the use of a pre-defined whitelist (see \\ownref{M-370}) as targets a single increment. It recommends the manual neutralization of malicious elements in user input used for generating OS commands. This has to be done in every increment, strictly customized to the allowed characters in the special usecase.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Correct use of whitelist', 'ActionCo': '', 'Verification': 'While the use of output encoding can be verified in MCR and, if the encoding functionality is defined as sanitizing operation, can be automated in an ACA, this heavily depends on the correct whitelist. Here, it is more reliable to perform dynamic tests. AVS are well able to detect Command Injection vulnerabilities, and a MPT using extensive payloads, too.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '1', 'AVS_PI': '3', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['78'], 'Phases': ['Implementation']}, '233': {'Name': 'Validate After Combination', 'Effectiveness': '', 'Description': 'When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.', 'Agility': 'This measure affects every increment combining data from multiple sources. The measure advises to perform the validation after the combination.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing validation', 'ActionCo': '', 'Verification': 'Performing a MCR is the only applicable method to verify the validation after combining two values.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['88'], 'Phases': ['Implementation']}, '234': {'Name': 'Use Input Validation', 'Effectiveness': '', 'Description': "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing SQL query strings, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name O'Reilly would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ' apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded. When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.", 'Agility': 'Input validation can be done in different ways, using white- or blacklists. As described above, whitelisting is the recommended strategy. The exact strategy has to be defined for the respective system. To avoid inconsistencies, this should be done one-time for the developed system. In every affected increment, the strategy must not be bypassed but used in the correct way. Independently of that, the strategy has to be maintained continuously, including newly appearing security threats.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining input validation strategy', 'ActionPI': 'Correct use of strategy', 'ActionCo': 'Maintaining strategy', 'Verification': 'Using a MAR, the definition of the input validation strategy can be verified.\\\\The correct implementation of the strategy can be tested in multiple ways. Using ACA, the input validation operation (e.g. matching a whitelist) can be marked as sanitizing operation. Then, database operations not using the strategy can be detected as unsanitized taint flow. Also, the correct use can be reviewed targeted in a MCR. An AVS or a MPT are only able to detect the result of a missing or incorrect use of the strategy (the SQL Injection itself).\\\\ The maintenance of the strategy cannot be verified directly. It is conceivable to create a recurring reminder task in the used project management tool as MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['89'], 'Phases': ['Implementation']}, '246': {'Name': 'Generate Temporary Password', 'Effectiveness': '', 'Description': 'Assign a new temporary password rather than revealing the original password.', 'Agility': 'As passwords must not be stored in plaintext (see \\ownref{M-53}), this measure should be self-fulfilled. It affects the increment implementing the password recovery process.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing temporary password', 'ActionCo': '', 'Verification': 'The generation of a temporary password can be verified both in a MCR and in a MPT, but not in an automated method like ACA or AVS. The latter does not allow inspection of the generating method. To automate this, custom test cases checking the password reset process are possible, but these CAT can only decide if the received passwords are different. ', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '1', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['640'], 'Phases': ['Architecture and Design']}, '247': {'Name': 'Unify Encoding Between Components', 'Effectiveness': '', 'Description': 'Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.', 'Agility': 'Using a joint encoding for multiple components is not straightforward in agile projects as components emerge and change constantly. Therefore, a joint encoding has to be defined as a preliminary one-time action, each increment handling communication between two components has to follow the defined encoding rule set.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining joint encoding', 'ActionPI': 'Use of defined encoding', 'ActionCo': '', 'Verification': 'The definition of a joint encoding has to be verified in a MAR.\\\\ A MCR is the only applicable method to verify the encoding is used in both components.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['79'], 'Phases': ['Implementation']}, '248': {'Name': 'Run at Least Privilege', 'Effectiveness': '', 'Description': 'Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.', 'Agility': 'This mitigation measure consists out of two parts: Firstly, a runtime concept defining the accounts and privileges has to be established. In every increment, this concept has to be followed, and adapted if necessary.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Designing runtime concept', 'ActionPI': 'Following and adjusting runtime concept', 'ActionCo': '', 'Verification': 'The definition of the runtime concept can be verified using MAR. \\\\The correct realization of this concept is hard to verify, as itâ€™s effects are only visible at runtime, but dynamic methods cannot evaluate the rights the code is running with. Therefore, this measure has to be verified using MOC in the operation phase, assessing the configuration.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '3', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['22', '78'], 'Phases': ['Architecture and Design', 'Operation']}, '253': {'Name': 'Configure Error Messages', 'Effectiveness': '', 'Description': 'Where available, configure the environment to use less verbose error messages. For example, in PHP, disable the display\\_errors setting during configuration, or at runtime using the error\\_reporting() function.', 'Agility': 'This measure is a one-time action regarding the configuration of the environment to be less verbose.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Configuring environment', 'ActionPI': '', 'ActionCo': '', 'Verification': 'This measure can be verified by manually checking the configuration once regarding the defined error messages. Beside that, verbose error messages may be detected MPT and possibly using an AVS.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '1', 'MPT_OT': '1', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['209'], 'Phases': ['System Configuration']}, '275': {'Name': 'Use GET Request Correct', 'Effectiveness': '', 'Description': 'Do not use the GET method for any request that triggers a state change.', 'Agility': 'As intended, GET messages should not result in a state change. Considering this in every increment handling requests is recommended by this measure.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Use of GET request correct', 'ActionCo': '', 'Verification': 'This measure can be verified only by manual approaches as a state change has to be determined. Both MCR and MPT are possible to verify no GET messages are used triggering a state change.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['352'], 'Phases': ['Architecture and Design']}, '278': {'Name': 'Avoid Command Arguments', 'Effectiveness': '', 'Description': 'If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.', 'Agility': 'This detailed measure recommends using standard in or an input file over using command line arguments has to be considered in every increment calling OS commands.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing avoiding arguments', 'ActionCo': '', 'Verification': 'The precise way OS commands are called can only be examined by a white-box method. Therefore, a MCR is applicable to verify this measure. Using a ACA, it is not possibly to check for this exact measure.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['78'], 'Phases': ['Implementation']}, '279': {'Name': 'Perform Static Analysis', 'Effectiveness': '', 'Description': 'Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100\\% accuracy and coverage are not feasible.', 'Agility': 'This atypical measure is more a detection than a preventing or mitigation method. It has to be carried out continuously.', 'Source': 'CWE', 'Comment': 'Less Mitigation than Detection', 'ActionOT': '', 'ActionPI': '', 'ActionCo': 'Continuous testing', 'Verification': 'This atypical measure directly refers to ACA as detecting method.', 'VerificationSource': '', 'Type': ' Detection ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '3', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['88'], 'Phases': ['Testing']}, '280': {'Name': 'Restrict and Enumerate Objects', 'Effectiveness': '', 'Description': 'When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.', 'Agility': 'The mapping between the target URLs or filenames and the IDs has to be created once in the beginning. In every increment handling redirects, this mapping has to be used correctly, eventually a new entry has to be added to the map.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Establishing object map', 'ActionPI': 'Correct use of map and extending it', 'ActionCo': '', 'Verification': 'The establishment of the mapping consists of its design what can be checked in a MAR, and the technological implementation. The latter has to be verified in a MCR. \\\\The correct use of the mapping can be checked in two static ways. Firstly, a MCR can verify if it is implemented correctly. Secondly, when defining the mapping as sanitizing operation, a ACA can reveal command calls not using the map. In a dynamic approach, it is not visible how the commands are called.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '3', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['78', '79', '89'], 'Phases': ['Architecture and Design']}, '293': {'Name': 'Activate Struts Bean Filter', 'Effectiveness': '', 'Description': "With Struts, write all data from form beans with the bean's filter attribute set to true.", 'Agility': 'This detailed, Struts-specific measure has to be considered in every increment handling form beans.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Use of Bean Filter', 'ActionCo': '', 'Verification': 'Checking if this Struts-measure is used correctly is possible performing a MCR. An ACA is not possible, but custom testcases checking for the filter attribute may allow an automated verification by CAT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '3', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['79'], 'Phases': ['Implementation']}, '294': {'Name': 'Restrict and Enumerate Objects', 'Effectiveness': '', 'Description': 'When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to inbox.txt and ID 2 could map to profile.txt. Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.', 'Agility': 'The mapping between the target URLs or filenames and the IDs has to be created once in the beginning. In every increment handling redirects, this mapping has to be used correctly, eventually a new entry has to be added to the map.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Establishing object map', 'ActionPI': 'Correct use of map and extending it', 'ActionCo': '', 'Verification': 'The establishment of the mapping consists of its design what can be checked in a MAR, and the technological implementation. The latter has to be verified in a MCR. \\\\ The correct use of the mapping can be checked in multiple ways. Firstly, a MCR can verify if it is implemented correctly. Secondly, when defining the mapping as sanitizing operation, a ACA can reveal redirects not using the map. Lastly, a MPT may distinguish between the call to an arbitrary file object and enumerated target objects, depending on the implementation.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '3', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '1', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['22'], 'Phases': ['Architecture and Design']}, '299': {'Name': 'Create Default Error Pages', 'Effectiveness': '', 'Description': 'Create default error pages or messages that do not leak any information.', 'Agility': 'The creation of default error pages or messages is a measure only requiring a one-time action.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Creating Default Error Pages', 'ActionPI': '', 'ActionCo': '', 'Verification': 'The presence of custom error pages can be easily verified doing a MOC. In a MPT, error pages which leak information can be detected.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '2', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['209'], 'Phases': ['System Configuration']}, '321': {'Name': 'Check HTTP Referer', 'Effectiveness': '', 'Description': 'Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.', 'Agility': 'This measure having some drawbacks has to be considered in every increment handling requests.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Checking HTTP Referer', 'ActionCo': '', 'Verification': 'To verify this measure, every request handling has to be examined in a MCR. Alternatively, a MPT can verify a manipulated Referer is detected. Using automated techniques is not possible.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['352'], 'Phases': ['Implementation']}, '324': {'Name': 'Separate Code And Data', 'Effectiveness': '', 'Description': 'If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.', 'Agility': 'By separating code and data for database calls, command injections can be prevented. This has to be done during implementation of the single increments calling OS commands. If the language or platform used does not support such mechanisms, a library or framework has to be used (see \\ownref{M-186})', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Use of structured mechanisms', 'ActionCo': '', 'Verification': 'The use of the structured mechanisms can be verified in multiple ways: Using an ACA, the structured mechanisms function as sanitizing operations. In a MCR, the usage can be reviewed directly. Using dynamic approaches can only discover the weakness (XSS) itself, not the usage of the mechanisms. Anyhow, AVS and MPT are suitable to find these vulnerability.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['78'], 'Phases': ['Architecture and Design']}, '325': {'Name': 'Perform Dynamic Analysis', 'Effectiveness': '', 'Description': "Use dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.", 'Agility': 'This atypical measure is more a detection than a preventing or mitigation method. It has to be carried out continuously.', 'Source': 'CWE', 'Comment': 'Less Mitigation than Detection', 'ActionOT': '', 'ActionPI': '', 'ActionCo': 'Continuous testing', 'Verification': 'This atypical measure directly refers to AVS and MPT as detecting methods.', 'VerificationSource': '', 'Type': ' Detection ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '3', 'MPT_Co': '3', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['88'], 'Phases': ['Testing']}, '326': {'Name': 'Minimal Error Messages', 'Effectiveness': '', 'Description': 'Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages - but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not. In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.', 'Agility': 'At an early stage of development, an error handling policy should be established. For this measure, the database access has to be configured in a way handling errors in an appropriate way. Every increment has to follow this policy.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining error handling policy', 'ActionPI': 'Following policy', 'ActionCo': '', 'Verification': 'The error policy itself can be verified performing a MAR.\\\\ Using a MCR can verify the compliance with this policy, while a MPT can check if the displayed error messages are as minimal as designed. The automated equivalent, an ACA and a AVS may detect verbose or potentially leaking error messages, but need human intervention to interpret the findings.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '3', 'AVS_PI': '1', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['89'], 'Phases': ['Implementation']}, '339': {'Name': 'HttpOnly Cookie', 'Effectiveness': 'Defense in Depth', 'Description': "To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.", 'Agility': "This measure only prevents XSS attacks on the session cookie. It has to be realized in the increment setting the user's session cookie.", 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Setting HttpOnly for Session Cookie', 'ActionCo': '', 'Verification': 'Checking for a HttpOnly session cookie can be done using both static and dynamic approaches: In a MCR, the setting can be verified as well as in a MPT. Alternatively, an AVS can report not-HttpOnly cookies automatically.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '3', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['79'], 'Phases': ['Implementation']}, '370': {'Name': 'Use Input Validation', 'Effectiveness': '', 'Description': "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing OS command strings, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like ; and > characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components. Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.", 'Agility': 'Input validation can be realized in different ways, using white- or blacklists. As described above, whitelisting is the recommended strategy. The exact strategy has to be defined for the respective system. To avoid inconsistencies, this should be done one-time for the developed system. In every affected increment, the strategy must not be bypassed but used in the correct way. Independently of that, the strategy has to be maintained continuously, including new appearing security threats.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining input validation strategy', 'ActionPI': 'Correct use of strategy', 'ActionCo': 'Maintaining strategy', 'Verification': 'Using a MAR, the definition of the input validation strategy can be verified.\\\\The correct implementation of the strategy can be tested in multiple ways. Using ACA, the input validation operation (e.g. matching a whitelist) can be marked as sanitizing operation. Then, OS command calls containing data not sanitized can be detected as unsanitized taint flow. Also, the correct use can be reviewed targeted in a MCR. An AVS or a MPT are only able to detect the result of a missing or incorrect use of the strategy (the weakness itself).\\\\ The maintenance of the strategy cannot be verified directly. It is conceivable to create a recurring reminder task in the used project management tool as MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['78'], 'Phases': ['Implementation']}, '385': {'Name': 'Use Input Validation', 'Effectiveness': '', 'Description': "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When dynamically constructing web pages, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (<3) would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the < character, which would need to be escaped or otherwise handled. In this case, stripping the < might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities. Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address. Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.", 'Agility': 'Input validation can be realized in different ways, using white- or blacklists. As described above, whitelisting is the recommended strategy. The exact strategy has to be defined for the respective system. To avoid inconsistencies, this should be done one-time for the developed system. In every affected increment, the strategy must not be bypassed but used in the correct way. Independently of that, the strategy has to be maintained continuously, including new appearing security threats.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining input validation strategy', 'ActionPI': 'Correct use of strategy', 'ActionCo': 'Maintaining strategy', 'Verification': 'Using a MAR, the definition of the input validation strategy can be verified.\\\\The correct implementation of the strategy can be tested in multiple ways. Using ACA, the input validation operation (e.g. matching a whitelist) can be marked as sanitizing operation. Then, output operations not using the strategy can be detected as unsanitized taint flow. Also, the correct use can be reviewed targeted in a MCR. An AVS or a MPT are only able to detect the result of a missing or incorrect use of the library/framework (the weakness itself).\\\\ The maintenance of the strategy cannot be verified directly. It is conceivable to create a recurring reminder task in the used project management tool as MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '2', 'MPT_PI': '2', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['79'], 'Phases': ['Implementation']}, '386': {'Name': 'Separate Storage Locations', 'Effectiveness': '', 'Description': "Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately. This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.", 'Agility': 'Separating the storage locations of different files requires a predefined location concept structuring the different storage locations for different kinds of files. This has to be performed as a one-time action. Every increment adding new files (e.g. libraries) has to follow this concept', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Designing secure location concept', 'ActionPI': 'Following location concept', 'ActionCo': '', 'Verification': 'The design of secure storage solutions can only be verified in a MAR.\\\\A MCR can verify the correct usage of the storage strategy. As this measure is a mitigating one, it is hard to verify it in dynamic approaches.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['22'], 'Phases': ['Architecture and Design', 'Operation']}, '418': {'Name': "Configure PHP's register\\_globals", 'Effectiveness': '', 'Description': 'When using PHP, configure the application so that it does not use register\\_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register\\_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.', 'Agility': 'This PHP-specific measure can be fulfilled in a one-time action disabling register\\_globals. This enforces to develop increments not relying on this feature.', 'Source': 'CWE', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Do not use register\\_globals', 'ActionCo': '', 'Verification': 'As register\\_globals could be activated in every increment, this measure has to be realized as an action per increment. It has to be verified in a MOC. Alternatively, the check can be automated by a CAT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '3', 'ADC_PI': '0', 'MOC_PI': '3', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['22', '78', '79', '89'], 'Phases': ['Implementation', 'Operation']}, '432': {'Name': 'Minimal Error Messages', 'Effectiveness': '', 'Description': 'Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages - but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not. In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy.', 'Agility': 'At an early stage of development, an error handling policy should be established. For this measure, the filesystem access has to be configured so it handles errors in an appropriate way. Every increment has to follow this policy.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining error handling policy', 'ActionPI': 'Following policy', 'ActionCo': '', 'Verification': 'The error policy itself can be verified performing a MAR.\\\\ Using a MCR can verify the compliance with this policy, while a MPT can check if the displayed error messages are as minimal as designed. The automated equivalent, an ACA and a AVS may detect verbose or potentially leaking error messages, but need human intervention to interpret the findings.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '3', 'AVS_PI': '1', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['22'], 'Phases': ['Implementation']}, '462': {'Name': 'Run With Automatic Taint Analysis', 'Effectiveness': '', 'Description': "Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's -T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).", 'Agility': 'This measure can be realized with a one-time action in operation.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Enabling automatic taint analysis', 'ActionPI': '', 'ActionCo': '', 'Verification': 'This measure affects the operation of the application and should be verified using a MOC, checking if the automatic taint analysis is enabled. To automate this measure, ', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['78'], 'Phases': ['Operation']}, '554': {'Name': 'Minimal Error Messages', 'Effectiveness': '', 'Description': 'Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages - but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not. In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used.', 'Agility': 'At an early stage of development, an error handling policy should be established. For this measure, the OS access has to be configured so it handles errors in an appropriate way. Every increment has to follow this policy.', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining error handling policy', 'ActionPI': 'Following policy', 'ActionCo': '', 'Verification': 'The error policy itself can be verified performing a MAR.\\\\ Using a MCR can verify the compliance with this policy, while a MPT can check if the displayed error messages are as minimal as designed. The automated equivalent, an ACA and a AVS may detect verbose or potentially leaking error messages, but need human intervention to interpret the findings.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '3', 'AVS_PI': '1', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['78'], 'Phases': ['Implementation']}, '600': {'Name': 'Use Command Whitelists', 'Effectiveness': '', 'Description': 'Use runtime policy enforcement to create a whitelist of allowable commands, then prevent use of any command that does not appear in the whitelist. Technologies such as AppArmor are available to do this.', 'Agility': 'Defining a whitelist as part of the runtime policy enforcement allows to restrict the allowed OS commands to the needed ones. ', 'Source': 'CWE', 'Comment': '', 'ActionOT': 'Defining whitelist', 'ActionPI': 'Using and maintaining whitelist', 'ActionCo': '', 'Verification': 'The establishment of the whitelist consists of two parts: its design what can be checked in a MAR, and the technological implementation. The latter has to be in a MOC reviewing the server configuration. \\\\As long as the runtime policy enforcement is not bypassed, only the extension of the whitelist needs verification, what can be done in a MCR. As the measure is mitigating, other verifications are hard to perform.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['78'], 'Phases': ['Operation']}, '901': {'Name': 'Monitor Dependencies', 'Effectiveness': '', 'Description': 'Identify all components and the versions you are using, including all dependencies. Monitor the security of these components in public databases, project mailing lists, and security mailing lists, and keep them up to date. Establish security policies governing component use, such as requiring certain software development practices, passing security tests, and acceptable licenses.', 'Agility': 'Every increment adding a new dependency (e.g. a framework or library) has to add it to a list of used dependencies. This list has to be monitored continuously regarding updates and patches.', 'Source': 'owasp2013top', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Adding new monitored dependencies', 'ActionCo': 'Continuous monitoring', 'Verification': 'This measure is directly connected with the verification method ADC. By that, the used dependencies are collected (semi-)automated in every increment. \\\\ Additionally, they are monitored continuously.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '3', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '3', 'MOC_Co': '0', 'Weaknesses': ['937'], 'Phases': ['Deployment']}, '902': {'Name': 'Add Security Wrappers', 'Effectiveness': '', 'Description': 'Where appropriate, consider adding security wrappers around components to disable unused functionality and/ or secure weak or vulnerable aspects of the component.', 'Agility': 'In every increment adding a new dependency, it has to be considered to add a security wrapper.', 'Source': 'owasp2013top', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Adding security wrapper ', 'ActionCo': '', 'Verification': 'To verify this measure, a static analysis is necessary. By performing a MCR, the implementation of security wrappers can be checked. If those wrappers encapsulate weaknesses detectable by ACA, they may be defined as sanitizing operation.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['937'], 'Phases': ['Implementation']}, '1051': {'Name': 'Use of SSL', 'Effectiveness': '', 'Description': 'The application configuration should ensure that SSL or an encryption mechanism of equivalent strength and vetted reputation is used for all access-controlled pages.', 'Agility': 'This J2EE-specific measure corresponds to the more general measure \\ownref{M-56}. As that measure, it has to be considered one-time when configuring the encryption of the application.', 'Source': 'CWE', 'Comment': 'from CWE-4', 'ActionOT': 'Establishing SSL', 'ActionPI': '', 'ActionCo': '', 'Verification': 'Using SSL can be verified with dynamic tools as AVS or a MPT. Using static tools may be possible, too, but entails the risk the encryption does not work properly in the running system', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '1', 'MCR_OT': '1', 'AVS_OT': '3', 'MPT_OT': '3', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['5'], 'Phases': ['System Configuration']}, '1061': {'Name': '128bit Session Ids', 'Effectiveness': '', 'Description': 'Session identifiers should be at least 128 bits long to prevent brute-force session guessing. A shorter session identifier leaves the application open to brute-force session guessing attacks.', 'Agility': 'This measure proposes a clear requirement regarding the length of the session id. This minimum length has to be implemented in the increments issuing session ids.', 'Source': 'CWE', 'Comment': 'from CWE-4', 'ActionOT': '', 'ActionPI': 'Following minimum length', 'ActionCo': '', 'Verification': 'Verifying the length of session identifiers can be done statically in a MCR as well as in a MPT. Certain AVS may report too short identifiers, otherwise the creation a custom test checking the session idâ€™s length is possible.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '1', 'MPT_PI': '3', 'CAT_PI': '3', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['6'], 'Phases': ['Implementation']}, '1062': {'Name': 'Minimum Length for Session ID', 'Effectiveness': '', 'Description': 'A lower bound on the number of valid session identifiers that are available to be guessed is the number of users that are active on a site at any given moment. However, any users that abandon their sessions without logging out will increase this number. (This is one of many good reasons to have a short inactive session timeout.) With a 64 bit session identifier, assume 32 bits of entropy. For a large web site, assume that the attacker can try 1,000 guesses per second and that there are 10,000 valid session identifiers at any given moment. Given these assumptions, the expected time for an attacker to successfully guess a valid session identifier is less than 4 minutes. Now assume a 128 bit session identifier that provides 64 bits of entropy. With a very large web site, an attacker might try 10,000 guesses per second with 100,000 valid session identifiers available to be guessed. Given these assumptions, the expected time for an attacker to successfully guess a valid session identifier is greater than 292 years.', 'Agility': 'This measure gives a calculation method to determine a lower bound necessary taking into account the number of users simultanously active on the application. This measure can be seen as a preparatory action for \\ownref{M-1061} as a one-time action calculating the appropriate lower bound fo the length of the session identifier. When experiencing big changes in the user base, this lower bound may be adapted to the new situation.', 'Source': 'CWE', 'Comment': 'from CWE-4', 'ActionOT': 'Calculating lower bound regarding user base', 'ActionPI': '', 'ActionCo': 'Adapting lower bound to changes in user base', 'Verification': 'As this measure is affecting the requirements, it can only be verified in a MAR. \\\\Checking for a recurring recalculation cannot be verified, but it is conceivable to create a recurring reminder task in the used project management tool as MOC.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '1', 'Weaknesses': ['6'], 'Phases': ['Requirements']}, '1071': {'Name': 'Secure Exception Handling', 'Effectiveness': '', 'Description': 'Handle exceptions appropriately in source code.', 'Agility': 'This J2EE-specific measure corresponds to the more general measure \\ownref{M-69}. It has to be considered in every increment handling exceptions. ', 'Source': 'CWE', 'Comment': 'from CWE-4', 'ActionOT': '', 'ActionPI': 'Handling exceptions internally', 'ActionCo': '', 'Verification': 'This measure can be verified by multiple methods: Both manual test approaches, MCR and MPT can cover the verification of an internally exception handling. An ACA can detect when sensitive information are exposed in an error message, as well as a AVS can detect potentially verbose error messages. For automation, a human interpretation of the exposed information is necessary. ', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '3', 'AVS_PI': '1', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['7'], 'Phases': ['Implementation']}, '1072': {'Name': 'Create Default Error Pages', 'Effectiveness': '', 'Description': 'Always define appropriate error pages. The application configuration should specify a default error page in order to guarantee that the application will never leak error messages to an attacker. Handling standard HTTP error codes is useful and user-friendly in addition to being a good security practice, and a good configuration will also define a last-chance error handler that catches any exception that could possibly be thrown by the application.', 'Agility': 'This J2EE-specific measure corresponds to the more general measure \\ownref{M-299}. The creation of default error pages or messages is a measure only needing a one-time action. ', 'Source': 'CWE', 'Comment': 'from CWE-4', 'ActionOT': 'Creating Default Error Pages', 'ActionPI': '', 'ActionCo': '', 'Verification': 'The presence of custom error pages can be easily verified doing a MOC. In a MPT, error pages which leak information can be detected.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '1', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['7'], 'Phases': ['Implementation', 'System Configuration']}, '1073': {'Name': 'Proper Error Handling', 'Effectiveness': '', 'Description': 'Do not attempt to process an error or attempt to mask it.', 'Agility': 'This J2EE-specific measure addresses the fact that exceptions must not be processed to the user unmasked. This can be done by one-time by defining a filter catching all exceptions not handled internally before they reach the user. However, every increment should handle exceptions properly (see \\ownref{M-1071}).', 'Source': 'CWE', 'Comment': 'from CWE-4', 'ActionOT': 'Establishing top-level exception handling', 'ActionPI': '', 'ActionCo': '', 'Verification': 'This measure implements a top-level exception handling which can be verified in a MCR. It also can be marked as a sanitizing operation for taint analysis in an ACA. When performing dynamic tests, the correct functioning can be examined, but only a negative finding (â€œthe handling does not workâ€) is possible.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '3', 'AVS_OT': '1', 'MPT_OT': '1', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['7'], 'Phases': ['Implementation']}, '1074': {'Name': 'Verification of Return Values', 'Effectiveness': '', 'Description': 'Verify return values are correct and do not supply sensitive information about the system.', 'Agility': 'This measure is quite unspecific. As such, it has to be considered in every increment.', 'Source': 'CWE', 'Comment': 'from CWE-4', 'ActionOT': '', 'ActionPI': 'Ensuring proper return values', 'ActionCo': '', 'Verification': 'To decide whether a return value is supplying sensitive information needs human expertise. Therefore, performing a MCR or a MPT are the applicable verification methods for this measure.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['7', '12'], 'Phases': ['Implementation']}, '1081': {'Name': 'Local Java Beans', 'Effectiveness': '', 'Description': 'Declare Java beans "local" when possible. When a bean must be remotely accessible, make sure that sensitive information is not exposed, and ensure that the application logic performs appropriate validation of any data that might be modified by an attacker.', 'Agility': 'This measure is highly J2EE-specific. It demands to declare beans as "local" or to ensure not to expose sensitive information, what has to be done in every increment introducing a new entity bean.', 'Source': 'CWE', 'Comment': 'from CWE-4', 'ActionOT': '', 'ActionPI': 'Declaring beans as local or protect sensitive information', 'ActionCo': '', 'Verification': 'This measure has to be verified statically because it affects the implementation of Java beans. As the decision whether the bean can be local or not has to be done with human expertise, performing a MCR is suitable to verify this measure.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['8'], 'Phases': ['Implementation']}, '1091': {'Name': 'Least Privilege', 'Effectiveness': '', 'Description': 'Follow the principle of least privilege when assigning access rights to EJB methods. Permission to invoke EJB methods should not be granted to the ANYONE role.', 'Agility': 'To implement his J2EE-specific measure, EJB methods should get as little rights as possible. This has to be considered in every increment introducing new methods. See also \\ownref{M-248} for the more general measure.', 'Source': 'CWE', 'Comment': 'from CWE-4', 'ActionOT': '', 'ActionPI': 'Implementing EJB with least privilege', 'ActionCo': '', 'Verification': 'As this measure affects the implementation of Java beans, it has to be verified statically. The privileges of a bean can be examined using a MOC. As the decision what privileges the bean need to have has to be done with human expertise, an automation of this verification is difficult.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '3', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['9'], 'Phases': ['Architecture and Design', 'System Configuration']}, '1111': {'Name': 'Avoid Debug Binaries in Production', 'Effectiveness': '', 'Description': 'Avoid releasing debug binaries into the production environment. Change the debug mode to false when the application is deployed into production.', 'Agility': 'This ASP.NET-specific measure corresponds to the more general measure \\ownref{M-161}. Applied on this vulnerability, the build pipeline has to be configured such that it does not build a debug binary, but a production ready one.', 'Source': 'CWE', 'Comment': 'from CWE-519', 'ActionOT': 'Ensuring build of production artifacts', 'ActionPI': '', 'ActionCo': '', 'Verification': 'The automatic removal of debug information during the build process has to be checked manually examining the CD-pipeline as MOC. Beside that, the effect of not removing such information may be detected by AVS or MPT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '2', 'MPT_OT': '2', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['11'], 'Phases': ['System Configuration']}, '1121': {'Name': 'Secure Exception Handling', 'Effectiveness': '', 'Description': 'Handle exceptions appropriately in source code. ASP .NET applications should be configured to use custom error pages instead of the framework default page.', 'Agility': 'This ASP.NET-specific measure corresponds to the more general measures \\ownref{M-69} and \\ownref{M-299}. Defining error pages is a one-time action, while handling exceptions has to be considered in every increment handling exceptions. ', 'Source': 'CWE', 'Comment': 'from CWE-519', 'ActionOT': 'Creating Default Error Pages', 'ActionPI': 'Handling exceptions internally', 'ActionCo': '', 'Verification': 'The presence of custom error pages can be easily verified doing a MOC.\\\\The internal handling of exceptions can be verified by multiple methods: Both manual test approaches, MCR and MPT can cover the verification of an internally exception handling. An ACA can detect when sensitive information are exposed in an error message, as well as a AVS can detect potentially verbose error messages. For automation, a human interpretation of the exposed information is necessary. ', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '3', 'AVS_PI': '1', 'MPT_PI': '3', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['12'], 'Phases': ['System Configuration']}, '1122': {'Name': 'Proper Error Handling', 'Effectiveness': '', 'Description': 'Do not attempt to process an error or attempt to mask it.', 'Agility': 'This ASP.NET-specific measure addresses the fact that exceptions must not be processed to the user unmasked. This can be done by one-time by defining a filter catching all exceptions not handled internally before they reach the user. However, every increment should handle exceptions properly (see \\ownref{M-1121}).', 'Source': 'CWE', 'Comment': 'from CWE-519', 'ActionOT': 'Establishing top-level exception handling', 'ActionPI': '', 'ActionCo': '', 'Verification': 'This measure implements a top-level exception handling which can be verified in a MCR. It also can be marked as a sanitizing operation for taint analysis in an ACA. When performing dynamic tests, the correct functioning can be examined, but only a negative finding (â€œthe handling does not workâ€) is possible.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '3', 'AVS_OT': '2', 'MPT_OT': '2', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['12'], 'Phases': ['Architecture and Design']}, '1131': {'Name': 'Encrypt Credentials in Password Files', 'Effectiveness': '', 'Description': 'Credentials stored in configuration files should be encrypted, Use standard APIs and industry accepted algorithms to encrypt the credentials stored in configuration files.', 'Agility': 'This ASP.NET-specific measure is related to the more general measure \\ownref{M-38}. When the encryption algorithms is already selected, this measure takes place in every increment handling password in configuration files.', 'Source': 'CWE', 'Comment': 'from CWE-519', 'ActionOT': '', 'ActionPI': 'Encrypting password for configuration files', 'ActionCo': '', 'Verification': 'The encryption of password in configuration files is possible performing a MCR.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['13'], 'Phases': ['Implementation']}, '3201': {'Name': 'Store Keys Separately', 'Effectiveness': '', 'Description': 'For outbound authentication: store keys outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the encryption key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible. ', 'Agility': 'The protected, encrypted database should be established once beforehand. Every increment handling keys for outbound authentication has to use this location for securely storing the keys used.', 'Source': 'CWE', 'Comment': 'Mirrored from hard-coded password storage', 'ActionOT': 'Establishing secure location', 'ActionPI': 'Using secure location', 'ActionCo': '', 'Verification': 'The definition of secure storage solutions can only be verified in a MAR, while the technological establishment has to be checked in a MCR.\\\\ACA can partly verify this measure as they are able to detect hardcoded passwords, but cannot assure the measure itself is used properly. A MCR, in contrast, can verify the correct usage. An AVS or a MPT may detect if the passwords are stored in accessible locations.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '3', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '3', 'AVS_PI': '1', 'MPT_PI': '1', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['321'], 'Phases': ['Architecture and Design']}, '3202': {'Name': 'Utilize First Login Mode', 'Effectiveness': '', 'Description': 'For inbound authentication: Rather than hard-code a default key for first time logins, utilize a "first login" mode that requires the user to enter a unique strong key. ', 'Agility': 'An increment implementing an inbound authentication has to consider using a "first login" mode for creating a strong key.', 'Source': 'CWE', 'Comment': 'Mirrored from hard-coded password storage', 'ActionOT': '', 'ActionPI': 'Implementing first login mode', 'ActionCo': '', 'Verification': 'The implementation of this measure can be verified with a MCR as well as by performing a MPT testing the described functionality. For automation, the creation of a custom testcase covering the performed actions is possible as CAT.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '3', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['321'], 'Phases': ['Architecture and Design']}, '3203': {'Name': 'Limit Access to Features', 'Effectiveness': '', 'Description': 'Perform access control checks and limit which entities can access the feature that requires the hard-coded key. For example, a feature might only be enabled through the system console instead of through a network connection.', 'Agility': 'When implementing an increment containing a feature using a hard-coded key, the set of entities able to access this feature should be restricted. This can be supported by other measures (see \\ownref{M-43} or \\ownref{M-227}).', 'Source': 'CWE', 'Comment': 'Mirrored from hard-coded password storage', 'ActionOT': '', 'ActionPI': 'Limiting access to feature', 'ActionCo': '', 'Verification': 'As this measure is based on an implementation level, it has to be verified using a MCR.', 'VerificationSource': '', 'Type': ' Mitigation ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['321'], 'Phases': ['Architecture and Design']}, '3204': {'Name': 'Store Keys Hashed', 'Effectiveness': '', 'Description': 'For inbound authentication: apply strong one-way hashes to your keys and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the key. When receiving an incoming key during authentication, take the hash of the key and compare it to the hash that you have saved.Use randomly assigned salts for each separate hash that you generate. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method. ', 'Agility': 'Equivalent to passwords (see \\ownref{M-53}), this measure recommends to store keys for inbound authentication hashed. This has to be performed in every increment handling such keys.', 'Source': 'CWE', 'Comment': 'Mirrored from hard-coded password storage', 'ActionOT': '', 'ActionPI': 'Implementing hashing of keys', 'ActionCo': '', 'Verification': 'The hashed storage of keys can only be detected using in a white-box test. With a MCR, the measure is easily verifiable, and some ACA tools can also detect the storage of unhashed passwords (after doing some manually customizing)', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '3', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['321'], 'Phases': ['Architecture and Design']}, '3205': {'Name': 'Secure Front-End-to-Back-End', 'Effectiveness': '', 'Description': 'For front-end to back-end connections: Three solutions are possible, although none are complete.The first suggestion involves the use of generated keys which are changed automatically and must be entered at given time intervals by a system administrator. These keys will be held in memory and only be valid for the time intervals.Next, the keys used should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay style attacks. ', 'Agility': 'The design of front-end to back-end connections according to this measure is a one-time action. Every increment implementing such connections has to follow the established design.', 'Source': 'CWE', 'Comment': 'Mirrored from hard-coded password storage', 'ActionOT': 'Designing secure front-end to back-end connections', 'ActionPI': 'Following design', 'ActionCo': '', 'Verification': 'The design of the connections can be performed in a MAR.\\\\ If the implementation follows this design needs to be checked using a MCR.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['321'], 'Phases': ['Architecture and Design']}, '3251': {'Name': 'Exact Definition of Requirement', 'Effectiveness': '', 'Description': 'Clearly specify which cryptographic algorithm in which variant should be implemented, and give a concrete reference to the resource defining this algorithm.', 'Agility': 'This measure is related to the selection of strong encryption algorithm (see \\ownref{M-37}). As the selection of cryptographic algorithms is one-time action, this measure has to be considered in that step as well.', 'Source': '', 'Comment': '', 'ActionOT': 'Specification of cryptographic algorithm', 'ActionPI': '', 'ActionCo': '', 'Verification': 'As this measure is affecting the requirements, it can only be verified in a MAR. \\\\', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['325'], 'Phases': ['Requirements']}, '3471': {'Name': 'Check Signature of Files', 'Effectiveness': '', 'Description': 'When loading a file that is required to be cryptographically signed, e.g. a configuration file or a JAR-archive, verify the signature of this file prior to loading it. This can be done manually, or better by using the correct loading operation if present.', 'Agility': 'This measure has to be considered in every increment handling the loading of signed files. For these files, the signatures have to be checked properly.', 'Source': '', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing checks', 'ActionCo': '', 'Verification': 'To verify this measure, both static and dynamic approaches are possible: In a MCR, the correct use of the signature check can be verified. In a MPT, files with missing or tampered signature can be tested on acceptance. The latter may be put into a custom testcase for automated verification.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '3', 'CAT_PI': '3', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['347'], 'Phases': ['Implementation']}, '3472': {'Name': 'Check Signature of Messages', 'Effectiveness': '', 'Description': 'When processing a message that is required to be cryptographically signed, e.g. requests from other components, check the signature to verify the origin and integrity of the message. ', 'Agility': 'This measure has to be considered in every increment handling signed messages exchanged between components. For these messages, the signatures have to be checked properly.', 'Source': '', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing checks', 'ActionCo': '', 'Verification': 'Static and dynamic approaches are applicable to verify this measure: In a MCR, the correct use of the signature check can be verified. In a MPT, it may be possible to intercept messages and check for tampered signature can be tested on acceptance. The latter may be put into a custom testcase for automated verification.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '1', 'CAT_PI': '0', 'ADC_PI': '1', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['347'], 'Phases': ['Implementation']}, '4351': {'Name': 'Proper Specified Interfaces', 'Effectiveness': '', 'Description': 'The interfaces between two components in the system have to be properly defined. This includes a definition of format, encoding and content of exchanged messages, but also constraints to state machines implicitly or explicitly shared by the components', 'Agility': 'This measure can be divided in agile development projects. As a one-time action, a general definition, valid across the application, can be established. In every increment creating a new interface, it has to be defined according to the general rule set and its special requirements.', 'Source': '', 'Comment': '', 'ActionOT': 'General definitions', 'ActionPI': 'Specification of interface', 'ActionCo': '', 'Verification': 'The verification of the interfacesâ€™ general definition can be done using a MAR.\\\\ The specification of the individual interfaces has to be verified in a MAR as well.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '3', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['435'], 'Phases': ['Architecture and Design']}, '5201': {'Name': 'Run with Least Privilege', 'Effectiveness': '', 'Description': 'Run the application with limited privilege to the underlying operating and file system.', 'Agility': 'This measure is related to \\ownref{M-248}, but affects the operation phase. It can be implemented as a one-time action configuring the deployed application according to the designed runtime concept.', 'Source': 'CWE', 'Comment': 'from CWE-519', 'ActionOT': 'Deploying application correctly', 'ActionPI': '', 'ActionCo': '', 'Verification': 'This measure can be verified by manually checking the configuration once regarding the defined privileges as MOC. As the measure is mitigating, it is difficult to use other verification methods.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '3', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['520'], 'Phases': ['Operation']}, '5541': {'Name': 'Use ASP.NET Validation Framework', 'Effectiveness': '', 'Description': 'Use the ASP.NET validation framework to check all program input before it is processed by the application. Example uses of the validation framework include checking to ensure that: Phone number fields contain only valid characters in phone numbers Boolean values are only "T" or "F" Free-form strings are of a reasonable length and composition', 'Agility': 'This ASP.NET-specific measure demanding input validation is related to multiple weaknesses (see \\ownref{CWE-22}, \\ownref{CWE-77}, \\ownref{CWE-78}, \\ownref{CWE-79}, \\ownref{CWE-88}, \\ownref{CWE-89}, \\ownref{CWE-90}, \\ownref{CWE-91}, \\ownref{CWE-99}, \\ownref{CWE-601}) that can be prevented or mitigated by that. Therefore, this measure is considered as a one-time action deciding to use the ASP.NET Input Validation Framework, not to forget the actual use as described in the belonging measures (see \\ownref{M-5}, \\ownref{M-18}, \\ownref{M-46}, \\ownref{M-234}, \\ownref{M-370}, \\ownref{M-385}).', 'Source': 'CWE', 'Comment': 'from CWE-519', 'ActionOT': 'Integrating ASP.NET Input Validation Framework into design', 'ActionPI': '', 'ActionCo': '', 'Verification': 'The integration of the framework can be checked in a MAR.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['554'], 'Phases': ['Architecture and Design']}, '5551': {'Name': 'Avoid Hardcorded Passwords', 'Effectiveness': '', 'Description': 'Do not hardwire passwords into your software.', 'Agility': 'This J2EE-specific measure corresponds to the more generic measure \\ownref{M-7}.', 'Source': 'CWE', 'Comment': 'from CWE-4', 'ActionOT': 'Defining storage locations', 'ActionPI': 'Storage in correct locations', 'ActionCo': '', 'Verification': 'The definition of secure storage solutions can only be verified in a MAR.\\\\ACA can partly verify this measure as they are able to detect hardcoded passwords, but cannot assure the measure itself is used properly. A MCR, in contrast, can verify the correct usage. An AVS or a MPT can detect if the passwords are stored in accessible locations.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '1', 'MCR_PI': '3', 'AVS_PI': '1', 'MPT_PI': '1', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['555'], 'Phases': ['Architecture and Design']}, '5552': {'Name': 'Encrypt Password in Config Files', 'Effectiveness': '', 'Description': 'Use industry standard libraries to encrypt passwords before storage in configuration files.', 'Agility': 'This J2EE-specific measure is related to the more general measure \\ownref{M-38}. When the encryption algorithms is already selected, this measure takes place in every increment handling password in configuration files.', 'Source': 'CWE', 'Comment': 'from CWE-4', 'ActionOT': '', 'ActionPI': 'Encrypting password for configuration files', 'ActionCo': '', 'Verification': 'The encryption of password in configuration files is possible performing a MCR.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['555'], 'Phases': ['Architecture and Design']}, '5561': {'Name': 'Run with Least Privilege', 'Effectiveness': '', 'Description': 'Use the least privilege principle.', 'Agility': 'This is the .NET-equivilant for \\ownref{M-248}. Just like that measure, a runtime concept defining the accounts and privileges has to be established at first. In every increment, this concept has to be followed, and adapted if necessary.', 'Source': 'CWE', 'Comment': 'from CWE-519', 'ActionOT': 'Designing runtime concept', 'ActionPI': 'Following and adjusting runtime concept', 'ActionCo': '', 'Verification': 'The definition of the runtime concept can be verified using MAR. \\\\The correct realization of this concept is hard to verify, as itâ€™s effects are only visible at runtime, but dynamic methods cannot evaluate the rights the code is running with. Therefore, this measure has to be verified using manual checks in the operation phase, assessing the configuration.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '3', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '0', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '3', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['556'], 'Phases': ['Architecture and Design']}, '7801': {'Name': 'Use RSA with OAEP', 'Effectiveness': '', 'Description': 'Using RSA without OAEP is deterministic what allows an attacker to encrypt own messages and compare them to the ciphertext. To prevent such attacks, a padding like OAEP is used to make the encryption probabilistic. Therefore, OAEP has to be implemented resp., when using a crypto library, RSA with OAEP has to be used.', 'Agility': 'In the special case of measure \\ownref{M-3251}, RSA has to be implemented using OAEP. This has to be done in the increment implementing or using RSA; neither one-time nor continuous actions are necessary.', 'Source': 'RSAOAEP', 'Comment': '', 'ActionOT': '', 'ActionPI': 'Implementing RSA with OAEP', 'ActionCo': '', 'Verification': 'To verify the correct realization of this implementation measure, a static analysis has to be performed: Using a MCR, the use of OAEP can be verified.', 'VerificationSource': '', 'Type': ' Prevention ', 'MAR_OT': '0', 'ACA_OT': '0', 'MCR_OT': '0', 'AVS_OT': '0', 'MPT_OT': '0', 'CAT_OT': '0', 'ADC_OT': '0', 'MOC_OT': '0', 'MAR_PI': '0', 'ACA_PI': '0', 'MCR_PI': '3', 'AVS_PI': '0', 'MPT_PI': '0', 'CAT_PI': '0', 'ADC_PI': '0', 'MOC_PI': '0', 'MAR_Co': '0', 'ACA_Co': '0', 'MCR_Co': '0', 'AVS_Co': '0', 'MPT_Co': '0', 'CAT_Co': '0', 'ADC_Co': '0', 'MOC_Co': '0', 'Weaknesses': ['780'], 'Phases': ['Implementation']}}
export const owasps = 
{'1': {'Name': 'Injection', 'CWE-ID': '929', 'Intro': 'The top security risk in the 2013 OWASP Top Ten ranking is, as in 2010 and 2017, the presence of \\emph{Injection} flaws. Such flaws "occur when untrusted data is sent to an interpreter as part of a command or query" \\cite{owasp2013top}. This allows to inject malicious data into a SQL or LDAP query or an OS command which can lead to the execution of arbitrary commands on the server or the unauthorized access of content or data.\\\\In the CWE, this risk is mapped onto \\cntowaspone weaknesses, describing different kinds of injections.', 'Weaknesses': ['77', '78', '88', '89', '90', '91']}, '2': {'Name': 'Broken Authentication and Session Management', 'CWE-ID': '930', 'Intro': 'The second entry in the 2013 OWASP Top Ten ranking is \\emph{Broken Authentication and Session Management}. This risk is mapped onto \\cntowasptwo CWE weaknesses.', 'Weaknesses': ['256', '287', '311', '319', '384', '522', '523', '613', '620', '640']}, '3': {'Name': 'Cross-Site Scripting (XSS)', 'CWE-ID': '931', 'Intro': 'The CWE contains a single weakness "Improper Neutralization of Input During Web Page Generation (\'Cross-site Scripting\')" (CWE-79) that is mapped onto this risk.', 'Weaknesses': ['79']}, '4': {'Name': 'Insecure Direct Object References', 'CWE-ID': '932', 'Intro': 'There are \\cntowaspfour weaknesses in the CWE that are mapped on this OWASP-risk.', 'Weaknesses': ['22', '99', '639']}, '5': {'Name': 'Security Misconfiguration', 'CWE-ID': '933', 'Intro': 'With \\cntowaspfive single weaknesses mapped onto, this risk has the largest representation in the CWE. Note that twelve of these are out of the categories "J2EE Environment" and ".NET Environment" and therefore platform specific.', 'Weaknesses': ['5', '6', '7', '8', '9', '11', '12', '13', '14', '209', '215', '435', '520', '548', '554', '555', '556']}, '6': {'Name': 'Sensitive Data Exposure', 'CWE-ID': '934', 'Intro': 'The CWE contains \\cntowaspsix different weaknesses that are mapped onto this OWASP risk.', 'Weaknesses': ['295', '311', '312', '319', '321', '322', '323', '324', '325', '326', '327', '328', '329', '347', '780']}, '7': {'Name': 'Missing Function Level Access Control', 'CWE-ID': '935', 'Intro': 'In the CWE, \\cntowaspseven weaknesses are mapped onto this risk.', 'Weaknesses': ['285', '287']}, '8': {'Name': 'Cross-Site Request Forgery (CSRF) ', 'CWE-ID': '936', 'Intro': 'This risk is mapped one-to-one onto the CWE-352 "Cross-Site Request Forgery (CSRF)".', 'Weaknesses': ['352']}, '9': {'Name': 'Using Components with Known Vulnerabilities', 'CWE-ID': '937', 'Intro': 'As described in \\ref{sec:mapping}, this OWASP risk cannot be mapped onto original CWE weaknesses. That\'s why it is mapped onto "itself" (CWE-937) here.', 'Weaknesses': ['937']}, '10': {'Name': 'Unvalidated Redirects and Forwards', 'CWE-ID': '938', 'Intro': 'This risk is mapped onto the single weakness CWE-601 "URL Redirection to Untrusted Site (\'Open Redirect\')".', 'Weaknesses': ['601']}}
